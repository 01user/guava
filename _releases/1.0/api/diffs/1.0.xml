<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="Guava r01"
  jdversion="1.1.1">

<package name="com.google.common.base">
  <!-- start class com.google.common.base.CaseFormat -->
  <class name="CaseFormat" extends="java.lang.Enum&lt;com.google.common.base.CaseFormat&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.common.base.CaseFormat[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.common.base.CaseFormat"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="to" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="format" type="com.google.common.base.CaseFormat"/>
      <param name="s" type="java.lang.String"/>
      <doc>
      <![CDATA[Converts the specified {@code String s} from this format to the specified
 {@code format}. A "best effort" approach is taken; if {@code s} does not
 conform to the assumed format, then the behavior of this method is
 undefined but we make a reasonable effort at converting anyway.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility class for converting between various case formats.

 @author Mike Bostock
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.CaseFormat -->
  <!-- start class com.google.common.base.CharMatcher -->
  <class name="CharMatcher" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CharMatcher"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="is" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="match" type="char"/>
      <doc>
      <![CDATA[Returns a {@code char} matcher that matches only one specified character.]]>
      </doc>
    </method>
    <method name="isNot" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="match" type="char"/>
      <doc>
      <![CDATA[Returns a {@code char} matcher that matches any character except the one
 specified.

 <p>To negate another {@code CharMatcher}, use {@link #negate()}.]]>
      </doc>
    </method>
    <method name="anyOf" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a {@code char} matcher that matches any character present in the
 given character sequence.]]>
      </doc>
    </method>
    <method name="noneOf" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a {@code char} matcher that matches any character not present in
 the given character sequence.]]>
      </doc>
    </method>
    <method name="inRange" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startInclusive" type="char"/>
      <param name="endInclusive" type="char"/>
      <doc>
      <![CDATA[Returns a {@code char} matcher that matches any character in a given range
 (both endpoints are inclusive). For example, to match any lowercase letter
 of the English alphabet, use {@code CharMatcher.inRange('a', 'z')}.

 @throws IllegalArgumentException if {@code endInclusive < startInclusive}]]>
      </doc>
    </method>
    <method name="forPredicate" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="&lt;any&gt;"/>
      <doc>
      <![CDATA[Returns a matcher with identical behavior to the given {@link
 Character}-based predicate, but which operates on primitive {@code char}
 instances instead.]]>
      </doc>
    </method>
    <method name="matches" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <doc>
      <![CDATA[Determines a true or false value for the given character.]]>
      </doc>
    </method>
    <method name="negate" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a matcher that matches any character not matched by this matcher.]]>
      </doc>
    </method>
    <method name="and" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.base.CharMatcher"/>
      <doc>
      <![CDATA[Returns a matcher that matches any character matched by both this matcher
 and {@code other}.]]>
      </doc>
    </method>
    <method name="or" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.base.CharMatcher"/>
      <doc>
      <![CDATA[Returns a matcher that matches any character matched by either this matcher
 or {@code other}.]]>
      </doc>
    </method>
    <method name="precomputed" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@code char} matcher functionally equivalent to this one, but
 which may be faster to query than the original; your mileage may vary.
 Precomputation takes time and is likely to be worthwhile only if the
 precomputed matcher is queried many thousands of times.

 <p>The default precomputation is to cache the configuration of the original
 matcher in an eight-kilobyte bit array. In some situations this produces a
 matcher which is faster to query than the original.

 <p>The default implementation creates a new bit array and passes it to
 {@link #setBits(LookupTable)}.]]>
      </doc>
    </method>
    <method name="setBits"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="table" type="com.google.common.base.CharMatcher.LookupTable"/>
      <doc>
      <![CDATA[For use by implementors; sets the bit corresponding to each character ('\0'
 to '#') that matches this matcher in the given bit array, leaving all
 other bits untouched.

 <p>The default implementation loops over every possible character value,
 invoking {@link #matches} for each one.]]>
      </doc>
    </method>
    <method name="matchesAllOf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns {@code true} if a character sequence contains only matching
 characters.

 <p>The default implementation iterates over the sequence, invoking {@link
 #matches} for each character, until this returns {@code false} or the end
 is reached.

 @param sequence the character sequence to examine, possibly empty
 @return {@code true} if this matcher matches every character in the
     sequence, including when the sequence is empty]]>
      </doc>
    </method>
    <method name="matchesNoneOf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns {@code true} if a character sequence contains no matching
 characters.

 <p>The default implementation iterates over the sequence, invoking {@link
 #matches} for each character, until this returns {@code false} or the end is
 reached.

 @param sequence the character sequence to examine, possibly empty
 @return {@code true} if this matcher matches every character in the
     sequence, including when the sequence is empty]]>
      </doc>
    </method>
    <method name="indexIn" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns the index of the first matching character in a character sequence,
 or {@code -1} if no matching character is present.

 <p>The default implementation iterates over the sequence in forward order
 calling {@link #matches} for each character.

 @param sequence the character sequence to examine from the beginning
 @return an index, or {@code -1} if no character matches]]>
      </doc>
    </method>
    <method name="indexIn" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Returns the index of the first matching character in a character sequence,
 starting from a given position, or {@code -1} if no character matches after
 that position.

 <p>The default implementation iterates over the sequence in forward order,
 beginning at {@code start}, calling {@link #matches} for each character.

 @param sequence the character sequence to examine
 @param start the first index to examine; must be nonnegative and no
     greater than {@code sequence.length()}
 @return the index of the first matching character, guaranteed to be no less
     than {@code start}, or {@code -1} if no character matches
 @throws IndexOutOfBoundsException if start is negative or greater than
     {@code sequence.length()}]]>
      </doc>
    </method>
    <method name="lastIndexIn" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns the index of the last matching character in a character sequence,
 or {@code -1} if no matching character is present.

 <p>The default implementation iterates over the sequence in reverse order
 calling {@link #matches} for each character.

 @param sequence the character sequence to examine from the end
 @return an index, or {@code -1} if no character matches]]>
      </doc>
    </method>
    <method name="countIn" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns the number of matching characters found in a character sequence.]]>
      </doc>
    </method>
    <method name="removeFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a string containing all non-matching characters of a character
 sequence, in order. For example: <pre>   {@code

   CharMatcher.is('a').removeFrom("bazaar")}</pre>

 ... returns {@code "bzr"}.]]>
      </doc>
    </method>
    <method name="retainFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a string containing all matching characters of a character
 sequence, in order. For example: <pre>   {@code

   CharMatcher.is('a').retainFrom("bazaar")}</pre>

 ... returns {@code "aaa"}.]]>
      </doc>
    </method>
    <method name="replaceFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <param name="replacement" type="char"/>
      <doc>
      <![CDATA[Returns a string copy of the input character sequence, with each character
 that matches this matcher replaced by a given replacement character. For
 example: <pre>   {@code

   CharMatcher.is('a').replaceFrom("radar", 'o')}</pre>

 ... returns {@code "rodor"}.

 <p>The default implementation uses {@link #indexIn(CharSequence)} to find
 the first matching character, then iterates the remainder of the sequence
 calling {@link #matches(char)} for each character.

 @param sequence the character sequence to replace matching characters in
 @param replacement the character to append to the result string in place of
     each matching character in {@code sequence}
 @return the new string]]>
      </doc>
    </method>
    <method name="replaceFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <param name="replacement" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a string copy of the input character sequence, with each character
 that matches this matcher replaced by a given replacement sequence. For
 example: <pre>   {@code

   CharMatcher.is('a').replaceFrom("yaha", "oo")}</pre>

 ... returns {@code "yoohoo"}.

 <p><b>Note:</b> If the replacement is a fixed string with only one character,
 you are better off calling {@link #replaceFrom(CharSequence, char)} directly.

 @param sequence the character sequence to replace matching characters in
 @param replacement the characters to append to the result string in place
     of each matching character in {@code sequence}
 @return the new string]]>
      </doc>
    </method>
    <method name="trimFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a substring of the input character sequence that omits all
 characters this matcher matches from the beginning and from the end of the
 string. For example: <pre> {@code

   CharMatcher.anyOf("ab").trimFrom("abacatbab")}</pre>

 ... returns {@code "cat"}.

 <p>Note that<pre>   {@code

   CharMatcher.inRange('\0', ' ').trimFrom(str)}</pre>

 ... is equivalent to {@link String#trim()}.]]>
      </doc>
    </method>
    <method name="trimLeadingFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a substring of the input character sequence that omits all
 characters this matcher matches from the beginning of the
 string. For example: <pre> {@code

   CharMatcher.anyOf("ab").trimLeadingFrom("abacatbab")}</pre>

 ... returns {@code "catbab"}.]]>
      </doc>
    </method>
    <method name="trimTrailingFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a substring of the input character sequence that omits all
 characters this matcher matches from the end of the
 string. For example: <pre> {@code

   CharMatcher.anyOf("ab").trimTrailingFrom("abacatbab")}</pre>

 ... returns {@code "abacat"}.]]>
      </doc>
    </method>
    <method name="collapseFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <param name="replacement" type="char"/>
      <doc>
      <![CDATA[Returns a string copy of the input character sequence, with each group of
 consecutive characters that match this matcher replaced by a single
 replacement character. For example: <pre>   {@code

   CharMatcher.anyOf("eko").collapseFrom("bookkeeper", '-')}</pre>

 ... returns {@code "b-p-r"}.

 <p>The default implementation uses {@link #indexIn(CharSequence)} to find
 the first matching character, then iterates the remainder of the sequence
 calling {@link #matches(char)} for each character.

 @param sequence the character sequence to replace matching groups of
     characters in
 @param replacement the character to append to the result string in place of
     each group of matching characters in {@code sequence}
 @return the new string]]>
      </doc>
    </method>
    <method name="trimAndCollapseFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <param name="replacement" type="char"/>
      <doc>
      <![CDATA[Collapses groups of matching characters exactly as {@link #collapseFrom}
 does, except that groups of matching characters at the start or end of the
 sequence are removed without replacement.]]>
      </doc>
    </method>
    <method name="apply" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="character" type="java.lang.Character"/>
      <doc>
      <![CDATA[Returns {@code true} if this matcher matches the given character.

 @throws NullPointerException if {@code character} is null]]>
      </doc>
    </method>
    <field name="WHITESPACE" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is whitespace according to the latest
 Unicode standard, as illustrated
 <a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7Bwhitespace%7D">here</a>.
 This is not the same definition used by other Java APIs. See a comparison
 of several definitions of "whitespace" at
 <a href="http://go/white+space">go/white+space</a>.

 <b>Note:</b> as the Unicode definition evolves, we will modify this
 constant to keep it up to date.]]>
      </doc>
    </field>
    <field name="ASCII" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is ASCII, meaning that its code point is
 less than 128.]]>
      </doc>
    </field>
    <field name="DIGIT" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is a digit according to
 <a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7Bdigit%7D">Unicode</a>.]]>
      </doc>
    </field>
    <field name="JAVA_WHITESPACE" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is whitespace according to {@link
 Character#isWhitespace(char) Java's definition}; it is usually preferable
 to use {@link #WHITESPACE}. See a comparison of several definitions of
 "whitespace" at <a href="http://go/white+space">go/white+space</a>.]]>
      </doc>
    </field>
    <field name="JAVA_DIGIT" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is a digit according to {@link
 Character#isDigit(char) Java's definition}. If you only care to match
 ASCII digits, you can use {@code inRange('0', '9')}.]]>
      </doc>
    </field>
    <field name="JAVA_LETTER" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is a letter according to {@link
 Character#isLetter(char) Java's definition}. If you only care to match
 letters of the Latin alphabet, you can use {@code
 inRange('a', 'z').or(inRange('A', 'Z'))}.]]>
      </doc>
    </field>
    <field name="JAVA_LETTER_OR_DIGIT" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is a letter or digit according to {@link
 Character#isLetterOrDigit(char) Java's definition}.]]>
      </doc>
    </field>
    <field name="JAVA_UPPER_CASE" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is upper case according to {@link
 Character#isUpperCase(char) Java's definition}.]]>
      </doc>
    </field>
    <field name="JAVA_LOWER_CASE" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is lower case according to {@link
 Character#isLowerCase(char) Java's definition}.]]>
      </doc>
    </field>
    <field name="JAVA_ISO_CONTROL" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is an ISO control character according to
 {@link Character#isISOControl(char)}.]]>
      </doc>
    </field>
    <field name="INVISIBLE" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is invisible; that is, if its Unicode
 category is any of SPACE_SEPARATOR, LINE_SEPARATOR,
 PARAGRAPH_SEPARATOR, CONTROL, FORMAT, SURROGATE, and PRIVATE_USE according
 to ICU4J.]]>
      </doc>
    </field>
    <field name="SINGLE_WIDTH" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is single-width (not double-width).  When
 in doubt, this matcher errs on the side of returning {@code false} (that
 is, it tends to assume a character is double-width).

 <b>Note:</b> as the reference file evolves, we will modify this constant
 to keep it up to date.]]>
      </doc>
    </field>
    <field name="ANY" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Matches any character.]]>
      </doc>
    </field>
    <field name="NONE" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Matches no characters.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Determines a true or false value for any Java {@code char} value, just as
 {@link Predicate} does for any {@link Object}. Also offers basic text
 processing methods based on this function. Implementations are strongly
 encouraged to be side-effect-free and immutable.

 <p>Throughout the documentation of this class, the phrase "matching
 character" is used to mean "any character {@code c} for which {@code
 this.matches(c)} returns {@code true}".

 <p><b>Note:</b> This class deals only with {@code char} values; it does not
 understand supplementary Unicode code points in the range {@code 0x10000} to
 {@code 0x10FFFF}. Such logical characters are encoded into a {@code String}
 using surrogate pairs, and a {@code CharMatcher} treats these just as two
 separate characters.

 @author Kevin Bourrillion
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.CharMatcher -->
  <!-- start class com.google.common.base.CharMatcher.LookupTable -->
  <class name="CharMatcher.LookupTable" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="CharMatcher.LookupTable"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[A bit array with one bit per {@code char} value, used by {@link
 CharMatcher#precomputed}.

 <p>TODO: possibly share a common BitArray class with BloomFilter
 and others... a simpler java.util.BitSet.]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.CharMatcher.LookupTable -->
  <!-- start class com.google.common.base.Charsets -->
  <class name="Charsets" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="US_ASCII" type="java.nio.charset.Charset"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[US-ASCII: seven-bit ASCII, a.k.a. ISO646-US, a.k.a the Basic Latin block of
 the Unicode character set.]]>
      </doc>
    </field>
    <field name="ISO_8859_1" type="java.nio.charset.Charset"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[ISO-8859-1. ISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.]]>
      </doc>
    </field>
    <field name="UTF_8" type="java.nio.charset.Charset"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[UTF-8: eight-bit UCS Transformation Format.]]>
      </doc>
    </field>
    <field name="UTF_16BE" type="java.nio.charset.Charset"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[UTF-16BE: sixteen-bit UCS Transformation Format, big-endian byte order.]]>
      </doc>
    </field>
    <field name="UTF_16LE" type="java.nio.charset.Charset"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[UTF-16LE: sixteen-bit UCS Transformation Format, little-endian byte order.]]>
      </doc>
    </field>
    <field name="UTF_16" type="java.nio.charset.Charset"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[UTF-16: sixteen-bit UCS Transformation Format, byte order identified by an
 optional byte-order mark.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Contains constant definitions for the six standard {@link Charset}
 instances, which are guaranteed to be supported by all Java platform
 implementations.

 @author Mike Bostock
 @since 9.09.15]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Charsets -->
  <!-- start class com.google.common.base.Defaults -->
  <class name="Defaults" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="defaultValue" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the default value of {@code type} as defined by JLS --- {@code 0}
 for numbers, {@code false} for {@code boolean} and {@code '\0'} for {@code
 char}. For non-primitive types and {@code void}, null is returned.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class provides default values for all Java types, as defined by the JLS.

 @author Ben Yu]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Defaults -->
  <!-- start interface com.google.common.base.Service -->
  <interface name="Service"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="start" return="java.util.concurrent.Future&lt;com.google.common.base.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If the service state is {@link State#NEW}, this initiates service startup
 and returns immediately. If the service has already been started, this
 method returns immediately without taking action. A stopped service may not
 be restarted.

 @return a future for the startup result, regardless of whether this call
     initiated startup. Calling {@link Future#get} will block until the
     service has finished starting, and returns one of {@link
     State#RUNNING}, {@link State#STOPPING} or {@link State#TERMINATED}. If
     the service fails to start, {@link Future#get} will throw an {@link
     ExecutionException}, and the service's state will be {@link
     State#FAILED}. If it has already finished starting, {@link Future#get}
     returns immediately. Cancelling the returned future is unsupported and
     always returns {@code false}.]]>
      </doc>
    </method>
    <method name="startAndWait" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Initiates service startup (if necessary), returning once the service has
 finished starting. Unlike calling {@code start().get()}, this method throws
 no checked exceptions.

 @throws InterruptedRuntimeException if the thread was interrupted while
      waiting for the service to finish starting up.
 @throws RuntimeException if startup failed
 @return the state of the service when startup finished.]]>
      </doc>
    </method>
    <method name="isRunning" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if this service is {@link State#RUNNING running}.]]>
      </doc>
    </method>
    <method name="state" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the lifecycle state of the service.]]>
      </doc>
    </method>
    <method name="stop" return="java.util.concurrent.Future&lt;com.google.common.base.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If the service is {@link State#STARTING} or {@link State#RUNNING}, this
 initiates service shutdown and returns immediately. If this is {@link
 State#NEW}, it is {@link State#TERMINATED terminated} without having been
 started nor stopped.  If the service has already been stopped, this
 method returns immediately without taking action.

 @return a future for the shutdown result, regardless of whether this call
     initiated shutdown. Calling {@link Future#get} will block until the
     service has finished shutting down, and either returns {@link
     State#TERMINATED} or throws an {@link ExecutionException}. If it has
     already finished stopping, {@link Future#get} returns immediately.
     Cancelling this future is unsupported and always returns {@code
     false}.]]>
      </doc>
    </method>
    <method name="stopAndWait" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Initiates service shutdown (if necessary), returning once the service has
 finished stopping. If this is {@link State#STARTING}, startup will be
 cancelled. If this is {@link State#NEW}, it is {@link State#TERMINATED
 terminated} without having been started nor stopped. Unlike calling {@code
 stop().get()}, this method throws no checked exceptions.

 @throws InterruptedRuntimeException if the thread was interrupted while
      waiting for the service to finish shutting down.
 @throws RuntimeException if shutdown failed
 @return the state of the service when shutdown finished.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object with an operational state, plus asynchronous {@link #start()} and
 {@link #stop()} lifecycle methods to transfer into and out of this state.
 Example services include webservers, RPC servers and timers. The normal
 lifecycle of a service is:
 <ul>
   <li>{@link State#NEW} -&gt;</li>
   <li>{@link State#STARTING} -&gt;</li>
   <li>{@link State#RUNNING} -&gt;</li>
   <li>{@link State#STOPPING} -&gt;</li>
   <li>{@link State#TERMINATED}</li>
 </ul>

 If the service fails while starting, running or stopping, its state will be
 {@link State#FAILED}, and its behavior is undefined. Such a service cannot be
 started nor stopped.

 <p>Implementors of this interface are strongly encouraged to extend {@link
 com.google.common.util.concurrent.AbstractService} or {@link
 com.google.common.util.concurrent.AbstractExecutionThreadService}, which make
 the threading and state management easier.

 @author Jesse Wilson
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.base.Service -->
  <!-- start class com.google.common.base.Service.State -->
  <class name="Service.State" extends="java.lang.Enum&lt;com.google.common.base.Service.State&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.common.base.Service.State[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The lifecycle states of a service.]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Service.State -->
  <!-- start class com.google.common.base.Splitter -->
  <class name="Splitter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="on" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="char"/>
      <doc>
      <![CDATA[Returns a splitter that uses the given single-character separator. For
 example, {@code Splitter.on(',').split("foo,,bar")} returns an iterable
 containing {@code ["foo", "", "bar"]}.

 @param separator the character to recognize as a separator
 @return a splitter, with default settings, that recognizes that separator]]>
      </doc>
    </method>
    <method name="on" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separatorMatcher" type="com.google.common.base.CharMatcher"/>
      <doc>
      <![CDATA[Returns a splitter that considers any single character matched by the
 given {@code CharMatcher} to be a separator. For example, {@code
 Splitter.on(CharMatcher.anyOf(";,")).split("foo,;bar,quux")} returns an
 iterable containing {@code ["foo", "", "bar", "quux"]}.

 @param separatorMatcher a {@link CharMatcher} that determines whether a
     character is a separator
 @return a splitter, with default settings, that uses this matcher]]>
      </doc>
    </method>
    <method name="on" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a splitter that uses the given fixed string as a separator. For
 example, {@code Splitter.on(", ").split("foo, bar, baz,qux")} returns an
 iterable containing {@code ["foo", "bar", "baz,qux"]}.

 @param separator the literal, nonempty string to recognize as a separator
 @return a splitter, with default settings, that recognizes that separator]]>
      </doc>
    </method>
    <method name="on" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separatorPattern" type="java.util.regex.Pattern"/>
      <doc>
      <![CDATA[Returns a splitter that considers any subsequence matching {@code
 pattern} to be a separator. For example, {@code
 Splitter.on(Pattern.compile("\r?\n")).split(entireFile)} splits a string
 into lines whether it uses DOS-style or UNIX-style line terminators.

 @param separatorPattern the pattern that determines whether a subsequence
     is a separator. This pattern may not match the empty string.
 @return a splitter, with default settings, that uses this pattern
 @throws IllegalArgumentException if {@code separatorPattern} matches the
     empty string]]>
      </doc>
    </method>
    <method name="onPattern" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separatorPattern" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a splitter that considers any subsequence matching a given
 pattern (regular expression) to be a separator. For example, {@code
 Splitter.onPattern("\r?\n").split(entireFile)} splits a string into lines
 whether it uses DOS-style or UNIX-style line terminators. This is
 equivalent to {@code Splitter.on(Pattern.compile(pattern))}.

 @param separatorPattern the pattern that determines whether a subsequence
     is a separator. This pattern may not match the empty string.
 @return a splitter, with default settings, that uses this pattern
 @throws PatternSyntaxException if {@code separatorPattern} is a malformed
     expression
 @throws IllegalArgumentException if {@code separatorPattern} matches the
     empty string]]>
      </doc>
    </method>
    <method name="fixedLength" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Returns a splitter that divides strings into pieces of the given length.
 For example, {@code Splitter.atEach(2).split("abcde")} returns an
 iterable containing {@code ["ab", "cd", "e"]}. The last piece can be
 smaller than {@code length} but will never be empty.

 @param length the desired length of pieces after splitting
 @return a splitter, with default settings, that can split into fixed sized
     pieces]]>
      </doc>
    </method>
    <method name="omitEmptyStrings" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a splitter that behaves equivalently to {@code this} splitter, but
 automatically omits empty strings from the results. For example, {@code
 Splitter.on(',').omitEmptyStrings().split(",a,,,b,c,,")} returns an
 iterable containing only {@code ["a", "b", "c"]}.

 <p>If either {@code trimResults} option is also specified when creating a
 splitter, that splitter always trims results first before checking for
 emptiness. So, for example, {@code
 Splitter.on(':').omitEmptyStrings().trimResults().split(": : : ")} returns
 an empty iterable.
 
 <p>Note that it is ordinarily not possible for {@link #split(CharSequence)}
 to return an empty iterable, but when using this option, it can (if the
 input sequence consists of nothing but separators).

 @return a splitter with the desired configuration]]>
      </doc>
    </method>
    <method name="trimResults" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a splitter that behaves equivalently to {@code this} splitter, but
 automatically removes leading and trailing {@linkplain
 CharMatcher#WHITESPACE whitespace} from each returned substring; equivalent
 to {@code trimResults(CharMatcher.WHITESPACE)}. For example, {@code
 Splitter.on(',').trimResults().split(" a, b  ,c  ")} returns an iterable
 containing {@code ["a", "b", "c"]}.

 @return a splitter with the desired configuration]]>
      </doc>
    </method>
    <method name="trimResults" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="trimmer" type="com.google.common.base.CharMatcher"/>
      <doc>
      <![CDATA[Returns a splitter that behaves equivalently to {@code this} splitter, but
 removes all leading or trailing characters matching the given {@code
 CharMatcher} from each returned substring. For example, {@code
 Splitter.on(',').trimResults(CharMatcher.is('_')).split("_a ,_b_ ,c__")}
 returns an iterable containing {@code ["a ", "b_ ", "c"]}.

 @param trimmer a {@link CharMatcher} that determines whether a character
     should be removed from the beginning/end of a subsequence
 @return a splitter with the desired configuration]]>
      </doc>
    </method>
    <method name="split" return="java.lang.Iterable&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Splits the {@link CharSequence} passed in parameter.

 @param sequence the sequence of characters to split
 @return an iteration over the segments split from the parameter.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object that divides strings (or other instances of {@code CharSequence})
 into substrings, by recognizing a <i>separator</i> (a.k.a. "delimiter")
 which can be expressed as a single character, literal string, regular
 expression, {@code CharMatcher}, or by using a fixed substring length. This
 class provides the complementary functionality to {@link Joiner}.

 <p>Here is the most basic example of {@code Splitter} usage: <pre>   {@code

   Splitter.on(',').split("foo,bar")}</pre>

 This invocation returns an {@code Iterable<String>} containing {@code "foo"}
 and {@code "bar"}, in that order.

 <p>By default {@code Splitter}'s behavior is very simplistic: <pre>   {@code

   Splitter.on(',').split("foo,,bar,  quux")}</pre>

 This returns an iterable containing {@code ["foo", "", "bar", "  quux"]}.
 Notice that the splitter does not assume that you want empty strings removed,
 or that you wish to trim whitespace. If you want features like these, simply
 ask for them: <pre> {@code

   private static final Splitter MY_SPLITTER = Splitter.on(',')
       .trimResults()
       .omitEmptyStrings();}</pre>

 Now {@code MY_SPLITTER.split("foo, ,bar,  quux,")} returns an iterable
 containing just {@code ["foo", "bar", "quux"]}. Note that the order in which
 the configuration methods are called is never significant; for instance,
 trimming is always applied first before checking for an empty result,
 regardless of the order in which the {@link #trimResults()} and
 {@link #omitEmptyStrings()} methods were invoked.

 <p><b>Warning: splitter instances are always immutable</b>; a configuration
 method such as {@code omitEmptyStrings} has no effect on the instance it
 is invoked on! You must store and use the new splitter instance returned by
 the method. This makes splitters thread-safe, and safe to store as {@code
 static final} constants (as illustrated above). <pre>   {@code

   // Bad! Do not do this!
   Splitter splitter = Splitter.on('/');
   splitter.trimResults(); // does nothing!
   return splitter.split("wrong / wrong / wrong");}</pre>

 The separator recognized by the splitter does not have to be a single
 literal character as in the examples above. See the methods {@link
 #on(String)}, {@link #on(Pattern)} and {@link #on(CharMatcher)} for examples
 of other ways to specify separators.

 <p><b>Note:</b> this class does not mimic any of the quirky behaviors of
 similar JDK methods; for instance, it does not silently discard trailing
 separators, as does {@link String#split(String)}, nor does it have a default
 behavior of using five particular whitespace characters as separators, like
 {@link StringTokenizer}.
  
 @author Julien Silland
 @author Jesse Wilson
 @author Kevin Bourrillion
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Splitter -->
  <!-- start class com.google.common.base.Throwables -->
  <class name="Throwables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="propagateIfInstanceOf"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <param name="declaredType" type="java.lang.Class&lt;X&gt;"/>
      <exception name="Throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Propagates {@code throwable} exactly as-is, if and only if it is an
 instance of {@code declaredType}.  Example usage:
 <pre>
   try {
     someMethodThatCouldThrowAnything();
   } catch (IKnowWhatToDoWithThisException e) {
     handle(e);
   } catch (Throwable t) {
     Throwables.propagateIfInstanceOf(t, IOException.class);
     Throwables.propagateIfInstanceOf(t, SQLException.class);
     throw Throwables.propagate(t);
   }
 </pre>]]>
      </doc>
    </method>
    <method name="propagateIfPossible"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Propagates {@code throwable} exactly as-is, if and only if it is an
 instance of {@link RuntimeException} or {@link Error}.  Example usage:
 <pre>
   try {
     someMethodThatCouldThrowAnything();
   } catch (IKnowWhatToDoWithThisException e) {
     handle(e);
   } catch (Throwable t) {
     Throwables.propagateIfPossible(t);
     throw new RuntimeException("unexpected", t);
   }
 </pre>]]>
      </doc>
    </method>
    <method name="propagateIfPossible"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <param name="declaredType" type="java.lang.Class&lt;X&gt;"/>
      <exception name="Throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Propagates {@code throwable} exactly as-is, if and only if it is an
 instance of {@link RuntimeException}, {@link Error}, or
 {@code declaredType}. Example usage:
 <pre>
   try {
     someMethodThatCouldThrowAnything();
   } catch (IKnowWhatToDoWithThisException e) {
     handle(e);
   } catch (Throwable t) {
     Throwables.propagateIfPossible(t, OtherException.class);
     throw new RuntimeException("unexpected", t);
   }
 </pre>

 @param throwable the Throwable to possibly propagate
 @param declaredType the single checked exception type declared by the
     calling method]]>
      </doc>
    </method>
    <method name="propagateIfPossible"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <param name="aDeclaredType" type="java.lang.Class&lt;X1&gt;"/>
      <param name="anotherDeclaredType" type="java.lang.Class&lt;X2&gt;"/>
      <exception name="Throwable" type="java.lang.Throwable"/>
      <exception name="Throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Propagates {@code throwable} exactly as-is, if and only if it is an
 instance of {@link RuntimeException}, {@link Error}, {@code aDeclaredType},
 or {@code anotherDeclaredType}.  In the unlikely case that you have three
 or more declared checked exception types, you can handle them all by
 invoking these methods repeatedly. See usage example in
 {@link #propagateIfPossible(Throwable, Class)}.

 @param throwable the Throwable to possibly propagate
 @param aDeclaredType any checked exception type declared by the calling
     method
 @param anotherDeclaredType any other checked exception type declared by the
     calling method]]>
      </doc>
    </method>
    <method name="propagate" return="java.lang.RuntimeException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Propagates {@code throwable} as-is if it is an instance of
 {@link RuntimeException} or {@link Error}, or else as a last resort, wraps
 it in a {@code RuntimeException} then propagates.
 <p>
 This method always throws an exception. The {@code RuntimeException} return
 type is only for client code to make Java type system happy in case a
 return value is required by the enclosing method. Example usage:
 <pre>
   T doSomething() {
     try {
       return someMethodThatCouldThrowAnything();
     } catch (IKnowWhatToDoWithThisException e) {
       return handle(e);
     } catch (Throwable t) {
       throw Throwables.propagate(t);
     }
   }
 </pre>

 @param throwable the Throwable to propagate
 @return nothing will ever be returned]]>
      </doc>
    </method>
    <method name="getRootCause" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Returns the innermost cause of {@code throwable}. The first throwable in a
 chain provides context from when the error or exception was initially
 detected. Example usage:
 <pre>
   assertEquals("Unable to assign a customer id",
       Throwables.getRootCause(e).getMessage());
 </pre>]]>
      </doc>
    </method>
    <method name="getCausalChain" return="java.util.List&lt;java.lang.Throwable&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Gets a {@code Throwable} cause chain as a list.  The first entry in the
 list will be {@code throwable} followed by its cause hierarchy.  Note
 that this is a snapshot of the cause chain and will not reflect
 any subsequent changes to the cause chain.

 <p>Here's an example of how it can be used to find specific types
 of exceptions in the cause chain:

 <pre>
 Iterables.filter(Throwables.getCausalChain(e), IOException.class));
 </pre>

 @param throwable the non-null {@code Throwable} to extract causes from
 @return an unmodifiable list containing the cause chain starting with
     {@code throwable}]]>
      </doc>
    </method>
    <method name="getStackTraceAsString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Returns a string containing the result of
 {@link Throwable#toString() toString()}, followed by the full, recursive
 stack trace of {@code throwable}. Note that you probably should not be
 parsing the resulting string; if you need programmatic access to the stack
 frames, you can call {@link Throwable#getStackTrace()}.]]>
      </doc>
    </method>
    <method name="throwCause" return="java.lang.Exception"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exception" type="java.lang.Exception"/>
      <param name="combineStackTraces" type="boolean"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Rethrows the cause exception of a given throwable, discarding the original
 throwable. Optionally, the stack frames of the cause and the outer
 exception are combined and the stack trace of the cause is set to this
 combined trace. If there is no cause the original exception is rethrown
 unchanged in all cases.

 @param exception the exception from which to extract the cause
 @param combineStackTraces if true the stack trace of the cause will be
     replaced by the concatenation of the trace from the exception and the
     trace from the cause.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to instances of {@link Throwable}.

 @author Kevin Bourrillion
 @author Ben Yu
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Throwables -->
</package>
<package name="com.google.common.io">
  <!-- start interface com.google.common.io.ByteArrayDataInput -->
  <interface name="ByteArrayDataInput"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.DataInput"/>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="skipBytes" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
    </method>
    <method name="readBoolean" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readByte" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readUnsignedByte" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readShort" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readUnsignedShort" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readChar" return="char"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readLine" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readUTF" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An extension of {@code DataInput} for reading from in-memory byte arrays; its
 methods offer identical functionality but do not throw {@link IOException}.
 If any method encounters the end of the array prematurely, it throws {@link
 IllegalStateException}.

 @author Kevin Bourrillion
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.io.ByteArrayDataInput -->
  <!-- start interface com.google.common.io.ByteArrayDataOutput -->
  <interface name="ByteArrayDataOutput"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.DataOutput"/>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="writeBoolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="boolean"/>
    </method>
    <method name="writeByte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
    </method>
    <method name="writeShort"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
    </method>
    <method name="writeChar"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
    </method>
    <method name="writeInt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
    </method>
    <method name="writeLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="long"/>
    </method>
    <method name="writeFloat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="float"/>
    </method>
    <method name="writeDouble"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="double"/>
    </method>
    <method name="writeChars"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
    </method>
    <method name="writeUTF"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
    </method>
    <method name="writeBytes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="This method is dangerous as it discards the high byte of
 every character. For UTF-8, use {@code write(s.getBytes(Charsets.UTF_8))}.">
      <param name="s" type="java.lang.String"/>
      <doc>
      <![CDATA[@deprecated This method is dangerous as it discards the high byte of
 every character. For UTF-8, use {@code write(s.getBytes(Charsets.UTF_8))}.]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the contents that have been written to this instance,
 as a byte array.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An extension of {@code DataOutput} for writing to in-memory byte arrays; its
 methods offer identical functionality but do not throw {@link IOException}.

 @author Jayaprabhakar Kadarkarai
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.io.ByteArrayDataOutput -->
  <!-- start interface com.google.common.io.ByteProcessor -->
  <interface name="ByteProcessor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="processBytes" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This method will be called for each chunk of bytes in an
 input stream. The implementation should process the bytes
 from {@code buf[off]} through {@code buf[off + len - 1]}
 (inclusive).

 @param buf the byte array containing the data to process
 @param off the initial offset into the array
 @param len the length of data to be processed
 @return true to continue processing, false to stop]]>
      </doc>
    </method>
    <method name="getResult" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the result of processing all the bytes.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A callback interface to process bytes from a stream.

 <p>{@link #processBytes} will be called for each line that is read, and
 should return {@code false} when you want to stop processing.

 @author Chris Nokleberg
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.io.ByteProcessor -->
  <!-- start class com.google.common.io.ByteStreams -->
  <class name="ByteStreams" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newInputStreamSupplier" return="com.google.common.io.InputSupplier&lt;java.io.ByteArrayInputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of
 {@link ByteArrayInputStream} that read from the given byte array.

 @param b the input buffer
 @return the factory]]>
      </doc>
    </method>
    <method name="newInputStreamSupplier" return="com.google.common.io.InputSupplier&lt;java.io.ByteArrayInputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of
 {@link ByteArrayInputStream} that read from the given byte array.

 @param b the input buffer
 @param off the offset in the buffer of the first byte to read
 @param len the maximum number of bytes to read from the buffer
 @return the factory]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="byte[]"/>
      <param name="to" type="com.google.common.io.OutputSupplier&lt;? extends java.io.OutputStream&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a byte array to an output stream from the given supplier.

 @param from the bytes to write
 @param to the output supplier
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <param name="to" type="com.google.common.io.OutputSupplier&lt;? extends java.io.OutputStream&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens input and output streams from the given suppliers, copies all
 bytes from the input to the output, and closes the streams.

 @param from the input factory
 @param to the output factory
 @return the number of bytes copied
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <param name="to" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an input stream from the supplier, copies all bytes from the
 input to the output, and closes the input stream. Does not close
 or flush the output stream.

 @param from the input factory
 @param to the output stream to write to
 @return the number of bytes copied
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.io.InputStream"/>
      <param name="to" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all bytes from the input stream to the output stream.
 Does not close or flush either stream.

 @param from the input stream to read from
 @param to the output stream to write to
 @return the number of bytes copied
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.nio.channels.ReadableByteChannel"/>
      <param name="to" type="java.nio.channels.WritableByteChannel"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all bytes from the readable channel to the writable channel.
 Does not close or flush either channel.

 @param from the readable channel to read from
 @param to the writable channel to write to
 @return the number of bytes copied
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all bytes from an input stream into a byte array.
 Does not close the stream.

 @param in the input stream to read from
 @return a byte array containing all the bytes from the stream
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the data from a {@link InputStream} factory as a byte array.

 @param supplier the factory
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="newDataInput" return="com.google.common.io.ByteArrayDataInput"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Returns a new {@link ByteArrayDataInput} instance to read from the {@code
 bytes} array from the beginning.]]>
      </doc>
    </method>
    <method name="newDataInput" return="com.google.common.io.ByteArrayDataInput"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Returns a new {@link ByteArrayDataInput} instance to read from the {@code
 bytes} array, starting at the given position.

 @throws IndexOutOfBoundsException if {@code start} is negative or greater
     than the length of the array]]>
      </doc>
    </method>
    <method name="newDataOutput" return="com.google.common.io.ByteArrayDataOutput"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new {@link ByteArrayDataOutput} instance with a default size.]]>
      </doc>
    </method>
    <method name="newDataOutput" return="com.google.common.io.ByteArrayDataOutput"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Returns a new {@link ByteArrayDataOutput} instance sized to hold
 {@code size} bytes before resizing.

 @throws IllegalArgumentException if {@code size} is negative]]>
      </doc>
    </method>
    <method name="length" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the length of a supplied input stream, in bytes.]]>
      </doc>
    </method>
    <method name="equal" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier1" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <param name="supplier2" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns true if the supplied input streams contain the same bytes.

 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="b" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Attempts to read enough bytes from the stream to fill the given byte array,
 with the same behavior as {@link DataInput#readFully(byte[])}.
 Does not close the stream.

 @param in the input stream to read from.
 @param b the buffer into which the data is read.
 @throws EOFException if this stream reaches the end before reading all
     the bytes.
 @throws IOException if an I/O error occurs.]]>
      </doc>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Attempts to read {@code len} bytes from the stream into the given array
 starting at {@code off}, with the same behavior as
 {@link DataInput#readFully(byte[], int, int)}. Does not close the
 stream.

 @param in the input stream to read from.
 @param b the buffer into which the data is read.
 @param off an int specifying the offset into the data.
 @param len an int specifying the number of bytes to read.
 @throws EOFException if this stream reaches the end before reading all
     the bytes.
 @throws IOException if an I/O error occurs.]]>
      </doc>
    </method>
    <method name="skipFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Discards {@code n} bytes of data from the input stream. This method
 will block until the full amount has been skipped. Does not close the
 stream.

 @param in the input stream to read from
 @param n the number of bytes to skip
 @throws EOFException if this stream reaches the end before skipping all
     the bytes
 @throws IOException if an I/O error occurs, or the stream does not
     support skipping]]>
      </doc>
    </method>
    <method name="readBytes" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <param name="processor" type="com.google.common.io.ByteProcessor&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Process the bytes of a supplied stream

 @param supplier the input stream factory
 @param processor the object to which to pass the bytes of the stream
 @return the result of the byte processor
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="getChecksum" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <param name="checksum" type="java.util.zip.Checksum"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Computes and returns the checksum value for a supplied input stream.
 The checksum object is reset when this method returns successfully.

 @param supplier the input stream factory
 @param checksum the checksum object
 @return the result of {@link Checksum#getValue} after updating the
     checksum object with all of the bytes in the stream
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="getDigest" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <param name="md" type="java.security.MessageDigest"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Computes and returns the digest value for a supplied input stream.
 The digest object is reset when this method returns successfully.

 @param supplier the input stream factory
 @param md the digest object
 @return the result of {@link MessageDigest#digest()} after updating the
     digest object with all of the bytes in the stream
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads some bytes from an input stream and stores them into the buffer array
 {@code b}. This method blocks until {@code len} bytes of input data have
 been read into the array, or end of file is detected. The number of bytes
 read is returned, possibly zero. Does not close the stream.

 <p>A caller can detect EOF if the number of bytes read is less than
 {@code len}. All subsequent calls on the same stream will return zero.

 <p>If {@code b} is null, a {@code NullPointerException} is thrown. If
 {@code off} is negative, or {@code len} is negative, or {@code off+len} is
 greater than the length of the array {@code b}, then an
 {@code IndexOutOfBoundsException} is thrown. If {@code len} is zero, then
 no bytes are read. Otherwise, the first byte read is stored into element
 {@code b[off]}, the next one into {@code b[off+1]}, and so on. The number
 of bytes read is, at most, equal to {@code len}.

 @param in the input stream to read from
 @param b the buffer into which the data is read
 @param off an int specifying the offset into the data
 @param len an int specifying the number of bytes to read
 @return the number of bytes read
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="slice" return="com.google.common.io.InputSupplier&lt;java.io.InputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <param name="offset" type="long"/>
      <param name="length" type="long"/>
      <doc>
      <![CDATA[Returns an {@link InputSupplier} that returns input streams from the
 an underlying supplier, where each stream starts at the given
 offset and is limited to the specified number of bytes.

 @param supplier the supplier from which to get the raw streams
 @param offset the offset in bytes into the underlying stream where
     the returned streams will start
 @param length the maximum length of the returned streams
 @throws IllegalArgumentException if offset or length are negative]]>
      </doc>
    </method>
    <method name="join" return="com.google.common.io.InputSupplier&lt;java.io.InputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="suppliers" type="java.lang.Iterable&lt;? extends com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;&gt;"/>
      <doc>
      <![CDATA[Joins multiple {@link InputStream} suppliers into a single supplier.
 Streams returned from the supplier will contain the concatenated data from
 the streams of the underlying suppliers.

 <p>Only one underlying input stream will be open at a time. Closing the
 joined stream will close the open underlying stream.

 <p>Reading from the joined stream will throw a {@link NullPointerException}
 if any of the suppliers are null or return null.

 @param suppliers the suppliers to concatenate
 @return a supplier that will return a stream containing the concatenated
     stream data]]>
      </doc>
    </method>
    <method name="join" return="com.google.common.io.InputSupplier&lt;java.io.InputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="suppliers" type="com.google.common.io.InputSupplier[]"/>
      <doc>
      <![CDATA[Varargs form of {@link #join(Iterable)}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides utility methods for working with byte arrays and I/O streams.

 <p>All method parameters must be non-null unless documented otherwise.

 @author Chris Nokleberg
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.ByteStreams -->
  <!-- start class com.google.common.io.CharStreams -->
  <class name="CharStreams" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newReaderSupplier" return="com.google.common.io.InputSupplier&lt;java.io.StringReader&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of {@link StringReader} that
 read a string value.

 @param value the string to read
 @return the factory]]>
      </doc>
    </method>
    <method name="newReaderSupplier" return="com.google.common.io.InputSupplier&lt;java.io.InputStreamReader&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of {@link InputStreamReader},
 using the given {@link InputStream} factory and character set.

 @param in the factory that will be used to open input streams
 @param charset the character set used to decode the input stream
 @return the factory]]>
      </doc>
    </method>
    <method name="newWriterSupplier" return="com.google.common.io.OutputSupplier&lt;java.io.OutputStreamWriter&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="com.google.common.io.OutputSupplier&lt;? extends java.io.OutputStream&gt;"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of {@link OutputStreamWriter},
 using the given {@link OutputStream} factory and character set.

 @param out the factory that will be used to open output streams
 @param charset the character set used to encode the output stream
 @return the factory]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.lang.CharSequence"/>
      <param name="to" type="com.google.common.io.OutputSupplier&lt;W&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a character sequence (such as a string) to an appendable
 object from the given supplier.

 @param from the character sequence to write
 @param to the output supplier
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="com.google.common.io.InputSupplier&lt;R&gt;"/>
      <param name="to" type="com.google.common.io.OutputSupplier&lt;W&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens {@link Readable} and {@link Appendable} objects from the
 given factories, copies all characters between the two, and closes
 them.

 @param from the input factory
 @param to the output factory
 @return the number of characters copied
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="com.google.common.io.InputSupplier&lt;R&gt;"/>
      <param name="to" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens a {@link Readable} object from the supplier, copies all characters
 to the {@link Appendable} object, and closes the input. Does not close
 or flush the output.

 @param from the input factory
 @param to the object to write to
 @return the number of characters copied
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.lang.Readable"/>
      <param name="to" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all characters between the {@link Readable} and {@link Appendable}
 objects. Does not close or flush either object.

 @param from the object to read from
 @param to the object to write to
 @return the number of characters copied
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="java.lang.Readable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all characters from a {@link Readable} object into a {@link String}.
 Does not close the {@code Readable}.

 @param r the object to read from
 @return a string containing all the characters
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;R&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the characters from a {@link Readable} & {@link Closeable} object
 supplied by a factory as a {@link String}.

 @param supplier the factory to read from
 @return a string containing all the characters
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readFirstLine" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;R&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads the first line from a {@link Readable} & {@link Closeable} object
 supplied by a factory. The line does not include line-termination
 characters, but does include other leading and trailing whitespace.

 @param supplier the factory to read from
 @return the first line, or null if the reader is empty
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readLines" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;R&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all of the lines from a {@link Readable} & {@link Closeable} object
 supplied by a factory. The lines do not include line-termination
 characters, but do include other leading and trailing whitespace.

 @param supplier the factory to read from
 @return a mutable {@link List} containing all the lines
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readLines" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="java.lang.Readable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all of the lines from a {@link Readable} object. The lines do
 not include line-termination characters, but do include other
 leading and trailing whitespace.

 <p>Does not close the {@code Readable}. If reading files or resources you
 should use the {@link Files#readLines} and {@link Resources#readLines}
 methods.

 @param r the object to read from
 @return a mutable {@link List} containing all the lines
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readLines" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;R&gt;"/>
      <param name="callback" type="com.google.common.io.LineProcessor&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Streams lines from a {@link Readable} and {@link Closeable} object
 supplied by a factory, stopping when our callback returns false, or we
 have read all of the lines.

 @param supplier the factory to read from
 @param callback the LineProcessor to use to handle the lines
 @return the output of processing the lines
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="join" return="com.google.common.io.InputSupplier&lt;java.io.Reader&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="suppliers" type="java.lang.Iterable&lt;? extends com.google.common.io.InputSupplier&lt;? extends java.io.Reader&gt;&gt;"/>
      <doc>
      <![CDATA[Joins multiple {@link Reader} suppliers into a single supplier.
 Reader returned from the supplier will contain the concatenated data
 from the readers of the underlying suppliers.

 <p>Reading from the joined reader will throw a {@link NullPointerException}
 if any of the suppliers are null or return null.

 <p>Only one underlying reader will be open at a time. Closing the
 joined reader will close the open underlying reader.

 @param suppliers the suppliers to concatenate
 @return a supplier that will return a reader containing the concatenated
     data]]>
      </doc>
    </method>
    <method name="join" return="com.google.common.io.InputSupplier&lt;java.io.Reader&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="suppliers" type="com.google.common.io.InputSupplier[]"/>
      <doc>
      <![CDATA[Varargs form of {@link #join(Iterable)}.]]>
      </doc>
    </method>
    <method name="skipFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Discards {@code n} characters of data from the reader. This method
 will block until the full amount has been skipped. Does not close the
 reader.

 @param reader the reader to read from
 @param n the number of characters to skip
 @throws EOFException if this stream reaches the end before skipping all
     the bytes
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="asWriter" return="java.io.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="java.lang.Appendable"/>
      <doc>
      <![CDATA[Returns a Writer that sends all output to the given {@link Appendable}
 target. Closing the writer will close the target if it is {@link
 Closeable}, and flushing the writer will flush the target if it is {@link
 java.io.Flushable}.

 @param target the object to which output will be sent
 @return a new Writer object, unless target is a Writer, in which case the
     target is returned]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides utility methods for working with character streams.

 <p>All method parameters must be non-null unless documented otherwise.

 <p>Some of the methods in this class take arguments with a generic type of
 {@code Readable & Closeable}. A {@link java.io.Reader} implements both of
 those interfaces. Similarly for {@code Appendable & Closeable} and
 {@link java.io.Writer}.

 @author Chris Nokleberg
 @author Bin Zhu
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.CharStreams -->
  <!-- start class com.google.common.io.Closeables -->
  <class name="Closeables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closeable" type="java.io.Closeable"/>
      <param name="swallowIOException" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Closes a {@link Closeable}, with control over whether an
 {@code IOException} may be thrown. This is primarily useful in a
 finally block, where a thrown exception needs to be logged but not
 propagated (otherwise the original exception will be lost).

 <p>If {@code swallowIOException} is true then we never throw
 {@code IOException} but merely log it.

 <p>Example:

 <p><pre>public void useStreamNicely() throws IOException {
 SomeStream stream = new SomeStream("foo");
 boolean threw = true;
 try {
   // Some code which does something with the Stream. May throw a
   // Throwable.
   threw = false; // No throwable thrown.
 } finally {
   // Close the stream.
   // If an exception occurs, only rethrow it if (threw==false).
   Closeables.close(stream, threw);
 }
 </pre>

 @param closeable the {@code Closeable} object to be closed, or null,
     in which case this method does nothing
 @param swallowIOException if true, don't propagate IO exceptions
     thrown by the {@code close} methods
 @throws IOException if {@code swallowIOException} is false and
     {@code close} throws an {@code IOException}.]]>
      </doc>
    </method>
    <method name="closeQuietly"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closeable" type="java.io.Closeable"/>
      <doc>
      <![CDATA[Equivalent to calling {@code close(closeable, true)}, but with no
 IOException in the signature.
 @param closeable the {@code Closeable} object to be closed, or null, in
      which case this method does nothing]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility methods for working with {@link Closeable} objects.

 @author Michael Lancaster
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.Closeables -->
  <!-- start class com.google.common.io.CountingInputStream -->
  <class name="CountingInputStream" extends="java.io.FilterInputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CountingInputStream" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Wraps another input stream, counting the number of bytes read.

 @param in the input stream to be wrapped]]>
      </doc>
    </constructor>
    <method name="getCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of bytes read.]]>
      </doc>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skip" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mark"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readlimit" type="int"/>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[An {@link InputStream} that counts the number of bytes read.

 @author Chris Nokleberg
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.CountingInputStream -->
  <!-- start class com.google.common.io.CountingOutputStream -->
  <class name="CountingOutputStream" extends="java.io.FilterOutputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CountingOutputStream" type="java.io.OutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Wraps another output stream, counting the number of bytes written.

 @param out the output stream to be wrapped]]>
      </doc>
    </constructor>
    <method name="getCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of bytes written.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[An OutputStream that counts the number of bytes written.

 @author Chris Nokleberg
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.CountingOutputStream -->
  <!-- start class com.google.common.io.FileBackedOutputStream -->
  <class name="FileBackedOutputStream" extends="java.io.OutputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="FileBackedOutputStream" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance that uses the given file threshold.
 Equivalent to {@code ThresholdOutputStream(fileThreshold, false)}.

 @param fileThreshold the number of bytes before the stream should
     switch to buffering to a file]]>
      </doc>
    </constructor>
    <constructor name="FileBackedOutputStream" type="int, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance that uses the given file threshold, and
 optionally resets the data when the {@link InputSupplier} returned
 by {@link #getSupplier} is finalized.

 @param fileThreshold the number of bytes before the stream should
     switch to buffering to a file
 @param resetOnFinalize if true, the {@link #reset} method will
     be called when the {@link InputSupplier} returned by {@link #getSupplier}
     is finalized]]>
      </doc>
    </constructor>
    <method name="getSupplier" return="com.google.common.io.InputSupplier&lt;java.io.InputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a supplier that may be used to retrieve the data buffered
 by this stream.]]>
      </doc>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Calls {@link #close} if not already closed, and then resets this
 object back to its initial state, for reuse. If data was buffered
 to a file, it will be deleted.

 @throws IOException if an I/O error occurred while deleting the file buffer]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[An {@link OutputStream} that starts buffering to a byte array, but
 switches to file buffering once the data reaches a configurable size.

 <p>This class is thread-safe.

 @author Chris Nokleberg
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.FileBackedOutputStream -->
  <!-- start class com.google.common.io.Files -->
  <class name="Files" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newReader" return="java.io.BufferedReader"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <doc>
      <![CDATA[Returns a buffered reader that reads from a file using the given
 character set.

 @param file the file to read from
 @param charset the character set used when writing the file
 @return the buffered reader]]>
      </doc>
    </method>
    <method name="newWriter" return="java.io.BufferedWriter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <doc>
      <![CDATA[Returns a buffered writer that writes to a file using the given
 character set.

 @param file the file to write to
 @param charset the character set used when writing the file
 @return the buffered writer]]>
      </doc>
    </method>
    <method name="newInputStreamSupplier" return="com.google.common.io.InputSupplier&lt;java.io.FileInputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of {@link FileInputStream}
 that read from a file.

 @param file the file to read from
 @return the factory]]>
      </doc>
    </method>
    <method name="newOutputStreamSupplier" return="com.google.common.io.OutputSupplier&lt;java.io.FileOutputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of {@link FileOutputStream}
 that write to a file.

 @param file the file to write to
 @return the factory]]>
      </doc>
    </method>
    <method name="newOutputStreamSupplier" return="com.google.common.io.OutputSupplier&lt;java.io.FileOutputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="append" type="boolean"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of {@link FileOutputStream}
 that write to or append to a file.

 @param file the file to write to
 @param append if true, the encoded characters will be appended to the file;
     otherwise the file is overwritten
 @return the factory]]>
      </doc>
    </method>
    <method name="newReaderSupplier" return="com.google.common.io.InputSupplier&lt;java.io.InputStreamReader&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of
 {@link InputStreamReader} that read a file using the given character set.

 @param file the file to read from
 @param charset the character set used when reading the file
 @return the factory]]>
      </doc>
    </method>
    <method name="newWriterSupplier" return="com.google.common.io.OutputSupplier&lt;java.io.OutputStreamWriter&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of {@link OutputStreamWriter}
 that write to a file using the given character set.

 @param file the file to write to
 @param charset the character set used when writing the file
 @return the factory]]>
      </doc>
    </method>
    <method name="newWriterSupplier" return="com.google.common.io.OutputSupplier&lt;java.io.OutputStreamWriter&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="append" type="boolean"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of {@link OutputStreamWriter}
 that write to or append to a file using the given character set.

 @param file the file to write to
 @param charset the character set used when writing the file
 @param append if true, the encoded characters will be appended to the file;
     otherwise the file is overwritten
 @return the factory]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all bytes from a file into a byte array.

 @param file the file to read from
 @return a byte array containing all the bytes from file
 @throws IllegalArgumentException if the file is bigger than the largest
     possible byte array (2^31 - 1)
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all characters from a file into a {@link String}, using the given
 character set.

 @param file the file to read from
 @param charset the character set used when reading the file
 @return a string containing all the characters from the file
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <param name="to" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies to a file all bytes from an {@link InputStream} supplied by a
 factory.

 @param from the input factory
 @param to the destination file
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="byte[]"/>
      <param name="to" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Overwrites a file with the contents of a byte array.

 @param from the bytes to write
 @param to the destination file
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.io.File"/>
      <param name="to" type="com.google.common.io.OutputSupplier&lt;? extends java.io.OutputStream&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all bytes from a file to an {@link OutputStream} supplied by
 a factory.

 @param from the source file
 @param to the output factory
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.io.File"/>
      <param name="to" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all bytes from a file to an output stream.

 @param from the source file
 @param to the output stream
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.io.File"/>
      <param name="to" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all the bytes from one file to another.
.
 @param from the source file
 @param to the destination file
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="com.google.common.io.InputSupplier&lt;R&gt;"/>
      <param name="to" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies to a file all characters from a {@link Readable} and
 {@link Closeable} object supplied by a factory, using the given
 character set.

 @param from the readable supplier
 @param to the destination file
 @param charset the character set used when writing the file
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.lang.CharSequence"/>
      <param name="to" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a character sequence (such as a string) to a file using the given
 character set.

 @param from the character sequence to write
 @param to the destination file
 @param charset the character set used when writing the file
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.lang.CharSequence"/>
      <param name="to" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Appends a character sequence (such as a string) to a file using the given
 character set.

 @param from the character sequence to append
 @param to the destination file
 @param charset the character set used when writing the file
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="to" type="com.google.common.io.OutputSupplier&lt;W&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all characters from a file to a {@link Appendable} &
 {@link Closeable} object supplied by a factory, using the given
 character set.

 @param from the source file
 @param charset the character set used when reading the file
 @param to the appendable supplier
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="to" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all characters from a file to an appendable object,
 using the given character set.

 @param from the source file
 @param charset the character set used when reading the file
 @param to the appendable object
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="equal" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file1" type="java.io.File"/>
      <param name="file2" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns true if the files contains the same bytes.

 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="createTempDir" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Atomically creates a new directory somewhere beneath the system's
 temporary directory (as defined by the {@code java.io.tmpdir} system
 property), and returns its name.

 <p>Use this method instead of {@link File#createTempFile(String, String)}
 when you wish to create a directory, not a regular file.  A common pitfall
 is to call {@code createTempFile}, delete the file and create a
 directory in its place, but this leads a race condition which can be
 exploited to create security vulnerabilities, especially when executable
 files are to be written into the directory.

 <p>This method assumes that the temporary volume is writable, has free
 inodes and free blocks, and that it will not be called thousands of times
 per second.

 @return the newly-created directory
 @throws IllegalStateException if the directory could not be created]]>
      </doc>
    </method>
    <method name="touch"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates an empty file or updates the last updated timestamp on the
 same as the unix command of the same name.

 @param file the file to create or update
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="move"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.io.File"/>
      <param name="to" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Moves the file from one path to another. This method can rename a file or
 move it to a different directory, like the Unix {@code mv} command.

 @param from the source file
 @param to the destination file
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="deleteDirectoryContents"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="directory" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Deletes all the files within a directory. Does not delete the
 directory itself.

 <p>If the file argument is a symbolic link this method will do
 nothing. Symbolic links within the directory are not followed.

 @param directory the directory to delete the contents of
 @throws IllegalArgumentException if the argument is not a directory
 @throws IOException if an I/O error occurs
 @see #deleteRecursively]]>
      </doc>
    </method>
    <method name="deleteRecursively"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Deletes a file or directory and all contents recursively.

 <p>If the file argument is a symbolic link the link will be deleted
 but not the target of the link. If the argument is a directory,
 symbolic links within the directory will not be followed.

 @param file the file to delete
 @throws IOException if an I/O error occurs
 @see #deleteDirectoryContents]]>
      </doc>
    </method>
    <method name="readFirstLine" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads the first line from a file. The line does not include
 line-termination characters, but does include other leading and
 trailing whitespace.

 @param file the file to read from
 @param charset the character set used when writing the file
 @return the first line, or null if the file is empty
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readLines" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all of the lines from a file. The lines do not include
 line-termination characters, but do include other leading and
 trailing whitespace.

 @param file the file to read from
 @param charset the character set used when writing the file
 @return a mutable {@link List} containing all the lines
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readLines" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="callback" type="com.google.common.io.LineProcessor&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Streams lines from a {@link File}, stopping when our callback returns
 false, or we have read all of the lines.

 @param file the file to read from
 @param charset the character set used when writing the file
 @param callback the {@link LineProcessor} to use to handle the lines
 @return the output of processing the lines
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readBytes" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="processor" type="com.google.common.io.ByteProcessor&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Process the bytes of a file.

 @param file the file to read
 @param processor the object to which to pass the bytes of the file
 @return the result of the byte processor
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="getChecksum" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="checksum" type="java.util.zip.Checksum"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Computes and returns the checksum value for a file.
 The checksum object is reset when this method returns successfully.

 @param file the file to read
 @param checksum the checksum object
 @return the result of {@link Checksum#getValue} after updating the
     checksum object with all of the bytes in the file
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="getDigest" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="md" type="java.security.MessageDigest"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Computes and returns the digest value for a file.
 The digest object is reset when this method returns successfully.

 @param file the file to read
 @param md the digest object
 @return the result of {@link MessageDigest#digest()} after updating the
     digest object with all of the bytes in this file
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides utility methods for working with files.

 <p>All method parameters must be non-null unless documented otherwise.

 @author Chris Nokleberg
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.Files -->
  <!-- start class com.google.common.io.Flushables -->
  <class name="Flushables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flushable" type="java.io.Flushable"/>
      <param name="swallowIOException" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Flush a {@link Flushable}, with control over whether an
 {@code IOException} may be thrown.

 <p>If {@code swallowIOException} is true, then we don't rethrow
 {@code IOException}, but merely log it.

 @param flushable the {@code Flushable} object to be flushed.
 @param swallowIOException if true, don't propagate IO exceptions
     thrown by the {@code flush} method
 @throws IOException if {@code swallowIOException} is false and
     {@link Flushable#flush} throws an {@code IOException}.
 @see Closeables#close]]>
      </doc>
    </method>
    <method name="flushQuietly"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flushable" type="java.io.Flushable"/>
      <doc>
      <![CDATA[Equivalent to calling {@code flush(flushable, true)}, but with no
 {@code IOException} in the signature.

 @param flushable the {@code Flushable} object to be flushed.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility methods for working with {@link Flushable} objects.

 @author Michael Lancaster
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.Flushables -->
  <!-- start interface com.google.common.io.InputSupplier -->
  <interface name="InputSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getInput" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[An factory for readable streams of bytes or characters.

 @author Chris Nokleberg
 @param <T> the type of object being supplied
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.io.InputSupplier -->
  <!-- start class com.google.common.io.LimitInputStream -->
  <class name="LimitInputStream" extends="java.io.FilterInputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LimitInputStream" type="java.io.InputStream, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Wraps another input stream, limiting the number of bytes which can be read.

 @param in the input stream to be wrapped
 @param limit the maximum number of bytes to be read]]>
      </doc>
    </constructor>
    <method name="available" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mark"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readlimit" type="int"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skip" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[An InputStream that limits the number of bytes which can be read.

 @author Charles Fry
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.LimitInputStream -->
  <!-- start interface com.google.common.io.LineProcessor -->
  <interface name="LineProcessor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="processLine" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="line" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This method will be called once for each line.

 @param line the line read from the input, without delimiter
 @return true to continue processing, false to stop]]>
      </doc>
    </method>
    <method name="getResult" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the result of processing all the lines.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A callback to be used with the streaming {@code readLines} methods.

 <p>{@link #processLine} will be called for each line that is read, and
 should return {@code false} when you want to stop processing.

 @author Miles Barr
 @param <T> the return type of {@link #getResult}
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.io.LineProcessor -->
  <!-- start class com.google.common.io.LineReader -->
  <class name="LineReader" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="LineReader" type="java.lang.Readable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance that will read lines from the given
 {@code Readable} object.]]>
      </doc>
    </constructor>
    <method name="readLine" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a line of text. A line is considered to be terminated by any
 one of a line feed ({@code '\n'}), a carriage return
 ({@code '\r'}), or a carriage return followed immediately by a linefeed
 ({@code "\r\n"}).

 @return a {@code String} containing the contents of the line, not
     including any line-termination characters, or {@code null} if the
     end of the stream has been reached.
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A class for reading lines of text. Provides the same functionality
 as {@link java.io.BufferedReader#readLine()} but for all {@link Readable}
 objects, not just instances of {@link Reader}.

 @author Chris Nokleberg
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.LineReader -->
  <!-- start class com.google.common.io.NullOutputStream -->
  <class name="NullOutputStream" extends="java.io.OutputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NullOutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <doc>
      <![CDATA[Discards the specified byte.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Discards the specified byte array.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implementation of {@link OutputStream} that simply discards written bytes.

 @author Spencer Kimball
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.NullOutputStream -->
  <!-- start interface com.google.common.io.OutputSupplier -->
  <interface name="OutputSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getOutput" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[An factory for writable streams of bytes or characters.

 @author Chris Nokleberg
 @param <T> the type of object being supplied
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.io.OutputSupplier -->
  <!-- start class com.google.common.io.PatternFilenameFilter -->
  <class name="PatternFilenameFilter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.FilenameFilter"/>
    <constructor name="PatternFilenameFilter" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a pattern file name filter object.
 @param patternStr the pattern string on which to filter file names

 @throws PatternSyntaxException if pattern compilation fails (runtime)]]>
      </doc>
    </constructor>
    <constructor name="PatternFilenameFilter" type="java.util.regex.Pattern"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a pattern file name filter object.
 @param pattern the pattern on which to filter file names]]>
      </doc>
    </constructor>
    <method name="accept" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.io.File"/>
      <param name="fileName" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[File name filter that only accepts files matching a regular expression.

 @author Apple Chow
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.PatternFilenameFilter -->
  <!-- start class com.google.common.io.Resources -->
  <class name="Resources" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Resources"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="newInputStreamSupplier" return="com.google.common.io.InputSupplier&lt;java.io.InputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of {@link InputStream} that
 read from the given URL.

 @param url the URL to read from
 @return the factory]]>
      </doc>
    </method>
    <method name="newReaderSupplier" return="com.google.common.io.InputSupplier&lt;java.io.InputStreamReader&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of
 {@link InputStreamReader} that read a URL using the given character set.

 @param url the URL to read from
 @param charset the character set used when reading the URL contents
 @return the factory]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all bytes from a URL into a byte array.

 @param url the URL to read from
 @return a byte array containing all the bytes from the URL
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all characters from a URL into a {@link String}, using the given
 character set.

 @param url the URL to read from
 @param charset the character set used when reading the URL
 @return a string containing all the characters from the URL
 @throws IOException if an I/O error occurs.]]>
      </doc>
    </method>
    <method name="readLines" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="callback" type="com.google.common.io.LineProcessor&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Streams lines from a URL, stopping when our callback returns false, or we
 have read all of the lines.

 @param url the URL to read from
 @param charset the character set used when reading the URL
 @param callback the LineProcessor to use to handle the lines
 @return the output of processing the lines
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readLines" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all of the lines from a URL. The lines do not include
 line-termination characters, but do include other leading and trailing
 whitespace.

 @param url the URL to read from
 @param charset the character set used when writing the file
 @return a mutable {@link List} containing all the lines
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.net.URL"/>
      <param name="to" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all bytes from a URL to an output stream.

 @param from the URL to read from
 @param to the output stream
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="getResource" return="java.net.URL"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="resourceName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a {@code URL} pointing to {@code resourceName} if the resource is
 found in the class path. {@code Resources.class.getClassLoader()} is used
 to locate the resource.
 
 @throws IllegalArgumentException if resource is not found]]>
      </doc>
    </method>
    <method name="getResource" return="java.net.URL"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contextClass" type="java.lang.Class&lt;?&gt;"/>
      <param name="resourceName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a {@code URL} pointing to {@code resourceName} that is relative to
 {@code contextClass}, if the resource is found in the class path. 
 
 @throws IllegalArgumentException if resource is not found]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides utility methods for working with resources in the classpath.
 Note that even those these methods use {@link URL} parameters, they
 are usually not appropriate for HTTP or other non-classpath resources.

 <p>All method parameters must be non-null unless documented otherwise.

 @author Chris Nokleberg
 @author Ben Yu
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.Resources -->
</package>
<package name="com.google.common.primitives">
  <!-- start class com.google.common.primitives.Booleans -->
  <class name="Booleans" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; equal to the result of invoking
 {@code ((Boolean) value).hashCode()}.

 @param value a primitive {@code boolean} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="boolean"/>
      <param name="b" type="boolean"/>
      <doc>
      <![CDATA[Compares the two specified {@code boolean} values in the standard way
 ({@code false} is considered less than {@code true}). The sign of the
 value returned is the same as that of {@code ((Boolean) a).compareTo(b)}.

 @param a the first {@code boolean} to compare
 @param b the second {@code boolean} to compare
 @return a positive number if only {@code a} is {@code true},  a negative
     number if only {@code b} is true, or zero if {@code a == b}]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="boolean[]"/>
      <param name="target" type="boolean"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in
 {@code array}.

 <p><b>Note:</b> consider representing the array as a {@link
 BitSet} instead, replacing {@code Booleans.contains(array, true)}
 with {@code !bitSet.isEmpty()} and {@code Booleans.contains(array, false)}
 with {@code bitSet.nextClearBit(0) == sizeOfBitSet}.

 @param array an array of {@code boolean} values, possibly empty
 @param target a primitive {@code boolean} value
 @return {@code true} if {@code array[i] == target} for some value of {@code
     i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="boolean[]"/>
      <param name="target" type="boolean"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in
 {@code array}.

 <p><b>Note:</b> consider representing the array as a {@link BitSet}
 instead, and using {@link BitSet#nextSetBit(int)} or {@link
 BitSet#nextClearBit(int)}.

 @param array an array of {@code boolean} values, possibly empty
 @param target a primitive {@code boolean} value
 @return the least index {@code i} for which {@code array[i] == target}, or
     {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="boolean[]"/>
      <param name="target" type="boolean[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code
 target} within {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code
 java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly
 the same elements as {@code target}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="boolean[]"/>
      <param name="target" type="boolean"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code boolean} values, possibly empty
 @param target a primitive {@code boolean} value
 @return the greatest index {@code i} for which {@code array[i] == target},
     or {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="concat" return="boolean[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="boolean[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array.
 For example, {@code concat(new boolean[] {a, b}, new boolean[] {}, new
 boolean[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code boolean} arrays
 @return a single array containing all the values from the source arrays, in
     order]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="boolean[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="boolean[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but
 guaranteed to be of a specified minimum length. If {@code array} already
 has a length of at least {@code minLength}, it is returned directly.
 Otherwise, a new array of size {@code minLength + padding} is returned,
 containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is
     necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is
     negative
 @return an array containing the values of {@code array}, with guaranteed
     minimum length {@code minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="boolean[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code boolean} values separated
 by {@code separator}. For example, {@code join("-", false, true, false)}
 returns the string {@code "false-true-false"}.

 @param separator the text that should appear between consecutive values in
     the resulting string (but not at the start or end)
 @param array an array of {@code boolean} values, possibly empty]]>
      </doc>
    </method>
    <method name="toArray" return="boolean[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;java.lang.Boolean&gt;"/>
      <doc>
      <![CDATA[Copies a collection of {@code Boolean} instances into a new array of
 primitive {@code boolean} values.

 <p><b>Note:</b> consider representing the collection as a {@link
 BitSet} instead.

 @param collection a collection of {@code Boolean} objects
 @return an array containing the same values as {@code collection}, in the
     same order, converted to primitives
 @throws NullPointerException if {@code collection} or any of its elements
     is null]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Boolean&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="boolean[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},
 but any attempt to set a value to {@code null} will result in a {@link
 NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of
 {@code Boolean} objects written to or read from it.  For example, whether
 {@code list.get(0) == list.get(0)} is true for the returned list is
 unspecified.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code boolean} primitives, that are not
 already found in either {@link Boolean} or {@link Arrays}.

 @author Kevin Bourrillion
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Booleans -->
  <!-- start class com.google.common.primitives.Bytes -->
  <class name="Bytes" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="byte"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; equal to the result of invoking
 {@code ((Byte) value).hashCode()}.

 @param value a primitive {@code byte} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="target" type="byte"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in
 {@code array}.

 @param array an array of {@code byte} values, possibly empty
 @param target a primitive {@code byte} value
 @return {@code true} if {@code array[i] == target} for some value of {@code
     i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="target" type="byte"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code byte} values, possibly empty
 @param target a primitive {@code byte} value
 @return the least index {@code i} for which {@code array[i] == target}, or
     {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="target" type="byte[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code
 target} within {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code
 java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly
 the same elements as {@code target}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="target" type="byte"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code byte} values, possibly empty
 @param target a primitive {@code byte} value
 @return the greatest index {@code i} for which {@code array[i] == target},
     or {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="concat" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="byte[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array.
 For example, {@code concat(new byte[] {a, b}, new byte[] {}, new
 byte[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code byte} arrays
 @return a single array containing all the values from the source arrays, in
     order]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but
 guaranteed to be of a specified minimum length. If {@code array} already
 has a length of at least {@code minLength}, it is returned directly.
 Otherwise, a new array of size {@code minLength + padding} is returned,
 containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is
     necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is
     negative
 @return an array containing the values of {@code array}, with guaranteed
     minimum length {@code minLength}]]>
      </doc>
    </method>
    <method name="toArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;java.lang.Byte&gt;"/>
      <doc>
      <![CDATA[Copies a collection of {@code Byte} instances into a new array of
 primitive {@code byte} values.

 @param collection a collection of {@code Byte} objects
 @return an array containing the same values as {@code collection}, in the
     same order, converted to primitives
 @throws NullPointerException if {@code collection} or any of its elements
     is null]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Byte&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="byte[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},
 but any attempt to set a value to {@code null} will result in a {@link
 NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of
 {@code Byte} objects written to or read from it.  For example, whether
 {@code list.get(0) == list.get(0)} is true for the returned list is
 unspecified.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code byte} primitives, that are not
 already found in either {@link Byte} or {@link Arrays}, <i>and interpret
 bytes as neither signed nor unsigned</i>. The methods which specifically
 treat bytes as signed or unsigned are found in {@link SignedBytes} and {@link
 UnsignedBytes}.

 @author Kevin Bourrillion
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Bytes -->
  <!-- start class com.google.common.primitives.Chars -->
  <class name="Chars" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="char"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; equal to the result of invoking
 {@code ((Character) value).hashCode()}.

 @param value a primitive {@code char} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="checkedCast" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code char} value that is equal to {@code value}, if possible.

 @param value any value in the range of the {@code char} type
 @return the {@code char} value that equals {@code value}
 @throws IllegalArgumentException if {@code value} is greater than {@link
     Character#MAX_VALUE} or less than {@link Character#MIN_VALUE}]]>
      </doc>
    </method>
    <method name="saturatedCast" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code char} nearest in value to {@code value}.

 @param value any {@code long} value
 @return the same value cast to {@code char} if it is in the range of the
     {@code char} type, {@link Character#MAX_VALUE} if it is too large,
     or {@link Character#MIN_VALUE} if it is too small]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="char"/>
      <param name="b" type="char"/>
      <doc>
      <![CDATA[Compares the two specified {@code char} values. The sign of the value
 returned is the same as that of {@code ((Character) a).compareTo(b)}.

 @param a the first {@code char} to compare
 @param b the second {@code char} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive
     value if {@code a} is greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="target" type="char"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in
 {@code array}.

 @param array an array of {@code char} values, possibly empty
 @param target a primitive {@code char} value
 @return {@code true} if {@code array[i] == target} for some value of {@code
     i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="target" type="char"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code char} values, possibly empty
 @param target a primitive {@code char} value
 @return the least index {@code i} for which {@code array[i] == target}, or
     {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="target" type="char[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code
 target} within {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code
 java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly
 the same elements as {@code target}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="target" type="char"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code char} values, possibly empty
 @param target a primitive {@code char} value
 @return the greatest index {@code i} for which {@code array[i] == target},
     or {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="min" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code char} values
 @return the value present in {@code array} that is less than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code char} values
 @return the value present in {@code array} that is greater than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="concat" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="char[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array.
 For example, {@code concat(new char[] {a, b}, new char[] {}, new
 char[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code char} arrays
 @return a single array containing all the values from the source arrays, in
     order]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="char"/>
      <doc>
      <![CDATA[Returns a big-endian representation of {@code value} in a 2-element byte
 array; equivalent to {@code
 ByteBuffer.allocate(2).putChar(value).array()}.  For example, the input
 value {@code '\\u5432'} would yield the byte array {@code {0x54, 0x32}}.

 <p>If you need to convert and concatenate several values (possibly even of
 different types), use a shared {@link java.nio.ByteBuffer} instance, or use
 {@link com.google.common.io.ByteStreams#newDataOutput()} to get a growable
 buffer.]]>
      </doc>
    </method>
    <method name="fromByteArray" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Returns the {@code char} value whose big-endian representation is
 stored in the first 2 bytes of {@code bytes}; equivalent to {@code
 ByteBuffer.wrap(bytes).getChar()}. For example, the input byte array
 {@code {0x54, 0x32}} would yield the {@code char} value {@code '\\u5432'}.

 <p>Arguably, it's preferable to use {@link java.nio.ByteBuffer}; that
 library exposes much more flexibility at little cost in readability.

 @throws IllegalArgumentException if {@code bytes} has fewer than 2
     elements]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but
 guaranteed to be of a specified minimum length. If {@code array} already
 has a length of at least {@code minLength}, it is returned directly.
 Otherwise, a new array of size {@code minLength + padding} is returned,
 containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is
     necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is
     negative
 @return an array containing the values of {@code array}, with guaranteed
     minimum length {@code minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="char[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code char} values separated
 by {@code separator}. For example, {@code join("-", '1', '2', '3')} returns
 the string {@code "1-2-3"}.

 @param separator the text that should appear between consecutive values in
     the resulting string (but not at the start or end)
 @param array an array of {@code char} values, possibly empty]]>
      </doc>
    </method>
    <method name="toArray" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;java.lang.Character&gt;"/>
      <doc>
      <![CDATA[Copies a collection of {@code Character} instances into a new array of
 primitive {@code char} values.

 @param collection a collection of {@code Character} objects
 @return an array containing the same values as {@code collection}, in the
     same order, converted to primitives
 @throws NullPointerException if {@code collection} or any of its elements
     is null]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Character&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="char[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},
 but any attempt to set a value to {@code null} will result in a {@link
 NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of
 {@code Character} objects written to or read from it.  For example, whether
 {@code list.get(0) == list.get(0)} is true for the returned list is
 unspecified.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <field name="BYTES" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of bytes required to represent a primitive {@code char}
 value.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code char} primitives, that are not
 already found in either {@link Character} or {@link Arrays}.

 @author Kevin Bourrillion
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Chars -->
  <!-- start class com.google.common.primitives.Doubles -->
  <class name="Doubles" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; equal to the result of invoking
 {@code ((Double) value).hashCode()}.

 @param value a primitive {@code double} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="double"/>
      <param name="b" type="double"/>
      <doc>
      <![CDATA[Compares the two specified {@code double} values. The sign of the value
 returned is the same as that of <code>((Double) a).{@linkplain
 Double#compareTo compareTo}(b)</code>. As with that method, {@code NaN} is
 treated as greater than all other values, and {@code 0.0 > -0.0}.

 @param a the first {@code double} to compare
 @param b the second {@code double} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive
     value if {@code a} is greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <param name="target" type="double"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in
 {@code array}. Note that this always returns {@code false} when {@code
 target} is {@code NaN}.

 @param array an array of {@code double} values, possibly empty
 @param target a primitive {@code double} value
 @return {@code true} if {@code array[i] == target} for some value of {@code
     i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <param name="target" type="double"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in
 {@code array}. Note that this always returns {@code -1} when {@code target}
 is {@code NaN}.

 @param array an array of {@code double} values, possibly empty
 @param target a primitive {@code double} value
 @return the least index {@code i} for which {@code array[i] == target}, or
     {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <param name="target" type="double[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code
 target} within {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code
 java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly
 the same elements as {@code target}.

 <p>Note that this always returns {@code -1} when {@code target} contains
 {@code NaN}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <param name="target" type="double"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in
 {@code array}. Note that this always returns {@code -1} when {@code target}
 is {@code NaN}.

 @param array an array of {@code double} values, possibly empty
 @param target a primitive {@code double} value
 @return the greatest index {@code i} for which {@code array[i] == target},
     or {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="min" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}, using the same rules of
 comparison as {@link Math#min(double, double)}.

 @param array a <i>nonempty</i> array of {@code double} values
 @return the value present in {@code array} that is less than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}, using the same rules
 of comparison as {@link Math#max(double, double)}.

 @param array a <i>nonempty</i> array of {@code double} values
 @return the value present in {@code array} that is greater than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="concat" return="double[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="double[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array.
 For example, {@code concat(new double[] {a, b}, new double[] {}, new
 double[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code double} arrays
 @return a single array containing all the values from the source arrays, in
     order]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="double[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but
 guaranteed to be of a specified minimum length. If {@code array} already
 has a length of at least {@code minLength}, it is returned directly.
 Otherwise, a new array of size {@code minLength + padding} is returned,
 containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is
     necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is
     negative
 @return an array containing the values of {@code array}, with guaranteed
     minimum length {@code minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="double[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code double} values, converted
 to strings as specified by {@link Double#toString(double)}, and separated
 by {@code separator}. For example, {@code join("-", 1.0, 2.0, 3.0)} returns
 the string {@code "1.0-2.0-3.0"}.

 @param separator the text that should appear between consecutive values in
     the resulting string (but not at the start or end)
 @param array an array of {@code double} values, possibly empty]]>
      </doc>
    </method>
    <method name="toArray" return="double[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;java.lang.Double&gt;"/>
      <doc>
      <![CDATA[Copies a collection of {@code Double} instances into a new array of
 primitive {@code double} values.

 @param collection a collection of {@code Double} objects
 @return an array containing the same values as {@code collection}, in the
     same order, converted to primitives
 @throws NullPointerException if {@code collection} or any of its elements
     is null]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Double&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="double[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},
 but any attempt to set a value to {@code null} will result in a {@link
 NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of
 {@code Double} objects written to or read from it.  For example, whether
 {@code list.get(0) == list.get(0)} is true for the returned list is
 unspecified.

 <p>The returned list may have unexpected behavior if it contains {@code
 NaN}, or if {@code NaN} is used as a parameter to any of its methods.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code double} primitives, that are not
 already found in either {@link Double} or {@link Arrays}.

 @author Kevin Bourrillion
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Doubles -->
  <!-- start class com.google.common.primitives.Floats -->
  <class name="Floats" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; equal to the result of invoking
 {@code ((Float) value).hashCode()}.

 @param value a primitive {@code float} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="float"/>
      <param name="b" type="float"/>
      <doc>
      <![CDATA[Compares the two specified {@code float} values using {@link
 Float#compare(float, float)}. You may prefer to invoke that method
 directly; this method exists only for consistency with the other utilities
 in this package.

 @param a the first {@code float} to compare
 @param b the second {@code float} to compare
 @return the result of invoking {@link Float#compare(float, float)}]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <param name="target" type="float"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in
 {@code array}. Note that this always returns {@code false} when {@code
 target} is {@code NaN}.

 @param array an array of {@code float} values, possibly empty
 @param target a primitive {@code float} value
 @return {@code true} if {@code array[i] == target} for some value of {@code
     i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <param name="target" type="float"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in
 {@code array}. Note that this always returns {@code -1} when {@code target}
 is {@code NaN}.

 @param array an array of {@code float} values, possibly empty
 @param target a primitive {@code float} value
 @return the least index {@code i} for which {@code array[i] == target}, or
     {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <param name="target" type="float[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code
 target} within {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code
 java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly
 the same elements as {@code target}.

 <p>Note that this always returns {@code -1} when {@code target} contains
 {@code NaN}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <param name="target" type="float"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in
 {@code array}. Note that this always returns {@code -1} when {@code target}
 is {@code NaN}.

 @param array an array of {@code float} values, possibly empty
 @param target a primitive {@code float} value
 @return the greatest index {@code i} for which {@code array[i] == target},
     or {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="min" return="float"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}, using the same rules of
 comparison as {@link Math#min(float, float)}.

 @param array a <i>nonempty</i> array of {@code float} values
 @return the value present in {@code array} that is less than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="float"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}, using the same rules
 of comparison as {@link Math#min(float, float)}.

 @param array a <i>nonempty</i> array of {@code float} values
 @return the value present in {@code array} that is greater than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="concat" return="float[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="float[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array.
 For example, {@code concat(new float[] {a, b}, new float[] {}, new
 float[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code float} arrays
 @return a single array containing all the values from the source arrays, in
     order]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="float[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but
 guaranteed to be of a specified minimum length. If {@code array} already
 has a length of at least {@code minLength}, it is returned directly.
 Otherwise, a new array of size {@code minLength + padding} is returned,
 containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is
     necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is
     negative
 @return an array containing the values of {@code array}, with guaranteed
     minimum length {@code minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="float[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code float} values, converted
 to strings as specified by {@link Float#toString(float)}, and separated by
 {@code separator}. For example, {@code join("-", 1.0f, 2.0f, 3.0f)}
 returns the string {@code "1.0-2.0-3.0"}.

 @param separator the text that should appear between consecutive values in
     the resulting string (but not at the start or end)
 @param array an array of {@code float} values, possibly empty]]>
      </doc>
    </method>
    <method name="toArray" return="float[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;java.lang.Float&gt;"/>
      <doc>
      <![CDATA[Copies a collection of {@code Float} instances into a new array of
 primitive {@code float} values.

 @param collection a collection of {@code Float} objects
 @return an array containing the same values as {@code collection}, in the
     same order, converted to primitives
 @throws NullPointerException if {@code collection} or any of its elements
     is null]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Float&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="float[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},
 but any attempt to set a value to {@code null} will result in a {@link
 NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of
 {@code Float} objects written to or read from it.  For example, whether
 {@code list.get(0) == list.get(0)} is true for the returned list is
 unspecified.

 <p>The returned list may have unexpected behavior if it contains {@code
 NaN}, or if {@code NaN} is used as a parameter to any of its methods.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code float} primitives, that are not
 already found in either {@link Float} or {@link Arrays}.

 @author Kevin Bourrillion
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Floats -->
  <!-- start class com.google.common.primitives.Ints -->
  <class name="Ints" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; equal to the result of invoking
 {@code ((Integer) value).hashCode()}.

 @param value a primitive {@code int} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="checkedCast" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code int} value that is equal to {@code value}, if possible.

 @param value any value in the range of the {@code int} type
 @return the {@code int} value that equals {@code value}
 @throws IllegalArgumentException if {@code value} is greater than {@link
     Integer#MAX_VALUE} or less than {@link Integer#MIN_VALUE}]]>
      </doc>
    </method>
    <method name="saturatedCast" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code int} nearest in value to {@code value}.

 @param value any {@code long} value
 @return the same value cast to {@code int} if it is in the range of the
     {@code int} type, {@link Integer#MAX_VALUE} if it is too large,
     or {@link Integer#MIN_VALUE} if it is too small]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="int"/>
      <param name="b" type="int"/>
      <doc>
      <![CDATA[Compares the two specified {@code int} values. The sign of the value
 returned is the same as that of {@code ((Integer) a).compareTo(b)}.

 @param a the first {@code int} to compare
 @param b the second {@code int} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive
     value if {@code a} is greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="target" type="int"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in
 {@code array}.

 @param array an array of {@code int} values, possibly empty
 @param target a primitive {@code int} value
 @return {@code true} if {@code array[i] == target} for some value of {@code
     i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="target" type="int"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code int} values, possibly empty
 @param target a primitive {@code int} value
 @return the least index {@code i} for which {@code array[i] == target}, or
     {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="target" type="int[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code
 target} within {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code
 java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly
 the same elements as {@code target}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="target" type="int"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code int} values, possibly empty
 @param target a primitive {@code int} value
 @return the greatest index {@code i} for which {@code array[i] == target},
     or {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="min" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code int} values
 @return the value present in {@code array} that is less than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code int} values
 @return the value present in {@code array} that is greater than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="concat" return="int[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="int[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array.
 For example, {@code concat(new int[] {a, b}, new int[] {}, new
 int[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code int} arrays
 @return a single array containing all the values from the source arrays, in
     order]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Returns a big-endian representation of {@code value} in a 4-element byte
 array; equivalent to {@code ByteBuffer.allocate(4).putInt(value).array()}.
 For example, the input value {@code 0x12131415} would yield the byte array
 {@code {0x12, 0x13, 0x14, 0x15}}.

 <p>If you need to convert and concatenate several values (possibly even of
 different types), use a shared {@link java.nio.ByteBuffer} instance, or use
 {@link com.google.common.io.ByteStreams#newDataOutput()} to get a growable
 buffer.

 <p><b>Warning:</b> do not use this method in GWT. It returns wrong answers.]]>
      </doc>
    </method>
    <method name="fromByteArray" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Returns the {@code int} value whose big-endian representation is stored in
 the first 4 bytes of {@code bytes}; equivalent to {@code
 ByteBuffer.wrap(bytes).getInt()}. For example, the input byte array {@code
 {0x12, 0x13, 0x14, 0x15, 0x33}} would yield the {@code int} value {@code
 0x12131415}.

 <p>Arguably, it's preferable to use {@link java.nio.ByteBuffer}; that
 library exposes much more flexibility at little cost in readability.

 <p><b>Warning:</b> do not use this method in GWT. It returns wrong answers.

 @throws IllegalArgumentException if {@code bytes} has fewer than 4 elements]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="int[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but
 guaranteed to be of a specified minimum length. If {@code array} already
 has a length of at least {@code minLength}, it is returned directly.
 Otherwise, a new array of size {@code minLength + padding} is returned,
 containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is
     necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is
     negative
 @return an array containing the values of {@code array}, with guaranteed
     minimum length {@code minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="int[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code int} values separated
 by {@code separator}. For example, {@code join("-", 1, 2, 3)} returns
 the string {@code "1-2-3"}.

 @param separator the text that should appear between consecutive values in
     the resulting string (but not at the start or end)
 @param array an array of {@code int} values, possibly empty]]>
      </doc>
    </method>
    <method name="toArray" return="int[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;java.lang.Integer&gt;"/>
      <doc>
      <![CDATA[Copies a collection of {@code Integer} instances into a new array of
 primitive {@code int} values.

 @param collection a collection of {@code Integer} objects
 @return an array containing the same values as {@code collection}, in the
     same order, converted to primitives
 @throws NullPointerException if {@code collection} or any of its elements
     is null]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Integer&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="int[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},
 but any attempt to set a value to {@code null} will result in a {@link
 NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of
 {@code Integer} objects written to or read from it.  For example, whether
 {@code list.get(0) == list.get(0)} is true for the returned list is
 unspecified.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <field name="BYTES" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of bytes required to represent a primitive {@code int}
 value.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code int} primitives, that are not
 already found in either {@link Integer} or {@link Arrays}.

 @author Kevin Bourrillion
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Ints -->
  <!-- start class com.google.common.primitives.Longs -->
  <class name="Longs" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; equal to the result of invoking
 {@code ((Long) value).hashCode()}.

 @param value a primitive {@code long} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="long"/>
      <param name="b" type="long"/>
      <doc>
      <![CDATA[Compares the two specified {@code long} values. The sign of the value
 returned is the same as that of {@code ((Long) a).compareTo(b)}.

 @param a the first {@code long} to compare
 @param b the second {@code long} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive
     value if {@code a} is greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="target" type="long"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in
 {@code array}.

 @param array an array of {@code long} values, possibly empty
 @param target a primitive {@code long} value
 @return {@code true} if {@code array[i] == target} for some value of {@code
     i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="target" type="long"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code long} values, possibly empty
 @param target a primitive {@code long} value
 @return the least index {@code i} for which {@code array[i] == target}, or
     {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="target" type="long[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code
 target} within {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code
 java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly
 the same elements as {@code target}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="target" type="long"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code long} values, possibly empty
 @param target a primitive {@code long} value
 @return the greatest index {@code i} for which {@code array[i] == target},
     or {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="min" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code long} values
 @return the value present in {@code array} that is less than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code long} values
 @return the value present in {@code array} that is greater than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="concat" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="long[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array.
 For example, {@code concat(new long[] {a, b}, new long[] {}, new
 long[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code long} arrays
 @return a single array containing all the values from the source arrays, in
     order]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns a big-endian representation of {@code value} in an 8-element byte
 array; equivalent to {@code ByteBuffer.allocate(8).putLong(value).array()}.
 For example, the input value {@code 0x1213141516171819L} would yield the
 byte array {@code {0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19}}.

 <p>If you need to convert and concatenate several values (possibly even of
 different types), use a shared {@link java.nio.ByteBuffer} instance, or use
 {@link com.google.common.io.ByteStreams#newDataOutput()} to get a growable
 buffer.

 <p><b>Warning:</b> do not use this method in GWT. It returns wrong answers.]]>
      </doc>
    </method>
    <method name="fromByteArray" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Returns the {@code long} value whose big-endian representation is
 stored in the first 8 bytes of {@code bytes}; equivalent to {@code
 ByteBuffer.wrap(bytes).getLong()}. For example, the input byte array
 {@code {0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19}} would yield the
 {@code long} value {@code 0x1213141516171819L}.

 <p>Arguably, it's preferable to use {@link java.nio.ByteBuffer}; that
 library exposes much more flexibility at little cost in readability.

 <p><b>Warning:</b> do not use this method in GWT. It returns wrong answers.

 @throws IllegalArgumentException if {@code bytes} has fewer than 8
     elements]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but
 guaranteed to be of a specified minimum length. If {@code array} already
 has a length of at least {@code minLength}, it is returned directly.
 Otherwise, a new array of size {@code minLength + padding} is returned,
 containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is
     necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is
     negative
 @return an array containing the values of {@code array}, with guaranteed
     minimum length {@code minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="long[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code long} values separated
 by {@code separator}. For example, {@code join("-", 1L, 2L, 3L)} returns
 the string {@code "1-2-3"}.

 @param separator the text that should appear between consecutive values in
     the resulting string (but not at the start or end)
 @param array an array of {@code long} values, possibly empty]]>
      </doc>
    </method>
    <method name="toArray" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;java.lang.Long&gt;"/>
      <doc>
      <![CDATA[Copies a collection of {@code Long} instances into a new array of
 primitive {@code long} values.

 @param collection a collection of {@code Long} objects
 @return an array containing the same values as {@code collection}, in the
     same order, converted to primitives
 @throws NullPointerException if {@code collection} or any of its elements
     is null]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Long&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="long[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},
 but any attempt to set a value to {@code null} will result in a {@link
 NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of
 {@code Long} objects written to or read from it.  For example, whether
 {@code list.get(0) == list.get(0)} is true for the returned list is
 unspecified.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <field name="BYTES" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of bytes required to represent a primitive {@code long}
 value.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code long} primitives, that are not
 already found in either {@link Long} or {@link Arrays}.

 @author Kevin Bourrillion
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Longs -->
  <!-- start class com.google.common.primitives.Primitives -->
  <class name="Primitives" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="isWrapperType" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code type} is one of the nine
 primitive-wrapper types, such as {@link Integer}.

 @see Class#isPrimitive]]>
      </doc>
    </method>
    <method name="wrap" return="java.lang.Class&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the corresponding wrapper type of {@code type} if it is a primitive
 type; otherwise returns {@code type} itself. Idempotent.
 <pre>
     wrap(int.class) == Integer.class
     wrap(Integer.class) == Integer.class
     wrap(String.class) == String.class
 </pre>]]>
      </doc>
    </method>
    <method name="unwrap" return="java.lang.Class&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the corresponding primitive type of {@code type} if it is a
 wrapper type; otherwise returns {@code type} itself. Idempotent.
 <pre>
     unwrap(Integer.class) == int.class
     unwrap(int.class) == int.class
     unwrap(String.class) == String.class
 </pre>]]>
      </doc>
    </method>
    <field name="PRIMITIVE_TO_WRAPPER_TYPE" type="java.util.Map&lt;java.lang.Class&lt;?&gt;, java.lang.Class&lt;?&gt;&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A map from primitive types to their corresponding wrapper types.]]>
      </doc>
    </field>
    <field name="WRAPPER_TO_PRIMITIVE_TYPE" type="java.util.Map&lt;java.lang.Class&lt;?&gt;, java.lang.Class&lt;?&gt;&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A map from wrapper types to their corresponding primitive types.]]>
      </doc>
    </field>
    <field name="PRIMITIVE_TYPES" type="java.util.Set&lt;java.lang.Class&lt;?&gt;&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[All nine primitive types (including void).]]>
      </doc>
    </field>
    <field name="WRAPPER_TYPES" type="java.util.Set&lt;java.lang.Class&lt;?&gt;&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[All nine wrapper types (including Void).]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Contains static utility methods pertaining to primitive types and their
 corresponding wrapper types.

 @author Kevin Bourrillion
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Primitives -->
  <!-- start class com.google.common.primitives.Shorts -->
  <class name="Shorts" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="short"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; equal to the result of invoking
 {@code ((Short) value).hashCode()}.

 @param value a primitive {@code short} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="checkedCast" return="short"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code short} value that is equal to {@code value}, if possible.

 @param value any value in the range of the {@code short} type
 @return the {@code short} value that equals {@code value}
 @throws IllegalArgumentException if {@code value} is greater than {@link
     Short#MAX_VALUE} or less than {@link Short#MIN_VALUE}]]>
      </doc>
    </method>
    <method name="saturatedCast" return="short"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code short} nearest in value to {@code value}.

 @param value any {@code long} value
 @return the same value cast to {@code short} if it is in the range of the
     {@code short} type, {@link Short#MAX_VALUE} if it is too large,
     or {@link Short#MIN_VALUE} if it is too small]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="short"/>
      <param name="b" type="short"/>
      <doc>
      <![CDATA[Compares the two specified {@code short} values. The sign of the value
 returned is the same as that of {@code ((Short) a).compareTo(b)}.

 @param a the first {@code short} to compare
 @param b the second {@code short} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive
     value if {@code a} is greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <param name="target" type="short"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in
 {@code array}.

 @param array an array of {@code short} values, possibly empty
 @param target a primitive {@code short} value
 @return {@code true} if {@code array[i] == target} for some value of {@code
     i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <param name="target" type="short"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code short} values, possibly empty
 @param target a primitive {@code short} value
 @return the least index {@code i} for which {@code array[i] == target}, or
     {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <param name="target" type="short[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code
 target} within {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code
 java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly
 the same elements as {@code target}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <param name="target" type="short"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code short} values, possibly empty
 @param target a primitive {@code short} value
 @return the greatest index {@code i} for which {@code array[i] == target},
     or {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="min" return="short"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code short} values
 @return the value present in {@code array} that is less than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="short"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code short} values
 @return the value present in {@code array} that is greater than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="concat" return="short[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="short[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array.
 For example, {@code concat(new short[] {a, b}, new short[] {}, new
 short[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code short} arrays
 @return a single array containing all the values from the source arrays, in
     order]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="short"/>
      <doc>
      <![CDATA[Returns a big-endian representation of {@code value} in a ?-element byte
 array; equivalent to {@code
 ByteBuffer.allocate(?).putShort(value).array()}.  For example, the input
 value {@code ?} would yield the byte array {@code {?}}.

 <p>If you need to convert and concatenate several values (possibly even of
 different types), use a shared {@link java.nio.ByteBuffer} instance, or use
 {@link com.google.common.io.ByteStreams#newDataOutput()} to get a growable
 buffer.]]>
      </doc>
    </method>
    <method name="fromByteArray" return="short"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Returns the {@code short} value whose big-endian representation is
 stored in the first ? bytes of {@code bytes}; equivalent to {@code
 ByteBuffer.wrap(bytes).getShort()}. For example, the input byte array
 {@code {?}} would yield the {@code short} value {@code ?}.

 <p>Arguably, it's preferable to use {@link java.nio.ByteBuffer}; that
 library exposes much more flexibility at little cost in readability.

 @throws IllegalArgumentException if {@code bytes} has fewer than ?
     elements]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="short[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but
 guaranteed to be of a specified minimum length. If {@code array} already
 has a length of at least {@code minLength}, it is returned directly.
 Otherwise, a new array of size {@code minLength + padding} is returned,
 containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is
     necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is
     negative
 @return an array containing the values of {@code array}, with guaranteed
     minimum length {@code minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="short[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code short} values separated
 by {@code separator}. For example, {@code join("-", 1?, 2?, 3?)} returns
 the string {@code "1-2-3"}.

 @param separator the text that should appear between consecutive values in
     the resulting string (but not at the start or end)
 @param array an array of {@code short} values, possibly empty]]>
      </doc>
    </method>
    <method name="toArray" return="short[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;java.lang.Short&gt;"/>
      <doc>
      <![CDATA[Copies a collection of {@code Short} instances into a new array of
 primitive {@code short} values.

 @param collection a collection of {@code Short} objects
 @return an array containing the same values as {@code collection}, in the
     same order, converted to primitives
 @throws NullPointerException if {@code collection} or any of its elements
     is null]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Short&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="short[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},
 but any attempt to set a value to {@code null} will result in a {@link
 NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of
 {@code Short} objects written to or read from it.  For example, whether
 {@code list.get(0) == list.get(0)} is true for the returned list is
 unspecified.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <field name="BYTES" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of bytes required to represent a primitive {@code short}
 value.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code short} primitives, that are not
 already found in either {@link Short} or {@link Arrays}.

 @author Kevin Bourrillion
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Shorts -->
  <!-- start class com.google.common.primitives.SignedBytes -->
  <class name="SignedBytes" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="checkedCast" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code byte} value that is equal to {@code value}, if possible.

 @param value any value in the range of the {@code byte} type
 @return the {@code byte} value that equals {@code value}
 @throws IllegalArgumentException if {@code value} is greater than {@link
     Byte#MAX_VALUE} or less than {@link Byte#MIN_VALUE}]]>
      </doc>
    </method>
    <method name="saturatedCast" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code byte} nearest in value to {@code value}.

 @param value any {@code long} value
 @return the same value cast to {@code byte} if it is in the range of the
     {@code byte} type, {@link Byte#MAX_VALUE} if it is too large,
     or {@link Byte#MIN_VALUE} if it is too small]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="byte"/>
      <param name="b" type="byte"/>
      <doc>
      <![CDATA[Compares the two specified {@code byte} values. The sign of the value
 returned is the same as that of {@code ((Byte) a).compareTo(b)}.

 @param a the first {@code byte} to compare
 @param b the second {@code byte} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive
     value if {@code a} is greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="min" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code byte} values
 @return the value present in {@code array} that is less than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code byte} values
 @return the value present in {@code array} that is greater than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code byte} values separated
 by {@code separator}. For example, {@code join(":", 0x01, 0x02, -0x01)}
 returns the string {@code "1:2:-1"}.

 @param separator the text that should appear between consecutive values in
     the resulting string (but not at the start or end)
 @param array an array of {@code byte} values, possibly empty]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code byte} primitives that
 interpret values as signed. The corresponding methods that treat the values
 as unsigned are found in {@link UnsignedBytes}, and the methods for which
 signedness is not an issue are in {@link Bytes}.

 @author Kevin Bourrillion
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.SignedBytes -->
  <!-- start class com.google.common.primitives.UnsignedBytes -->
  <class name="UnsignedBytes" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="checkedCast" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code byte} value that, when treated as unsigned, is equal to
 {@code value}, if possible.

 @param value a value between 0 and 255 inclusive
 @return the {@code byte} value that, when treated as unsigned, equals
     {@code value}
 @throws IllegalArgumentException if {@code value} is negative or greater
     than 255]]>
      </doc>
    </method>
    <method name="saturatedCast" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code byte} value that, when treated as unsigned, is nearest
 in value to {@code value}.

 @param value any {@code long} value
 @return {@code (byte) 255} if {@code value >= 255}, {@code (byte) 0} if
     {@code value <= 0}, and {@code value} cast to {@code byte} otherwise]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="byte"/>
      <param name="b" type="byte"/>
      <doc>
      <![CDATA[Compares the two specified {@code byte} values, treating them as unsigned
 values between 0 and 255 inclusive. For example, {@code (byte) -127} is
 considered greater than {@code (byte) 127} because it is seen as having
 the value of positive {@code 129}.

 @param a the first {@code byte} to compare
 @param b the second {@code byte} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive
     value if {@code a} is greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="min" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code byte} values
 @return the value present in {@code array} that is less than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code byte} values
 @return the value present in {@code array} that is greater than or equal
     to every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code byte} values separated by
 {@code separator}. For example, {@code join(":", (byte) 1, (byte) 2,
 (byte) 255)} returns the string {@code "1:2:255"}.

 @param separator the text that should appear between consecutive values in
     the resulting string (but not at the start or end)
 @param array an array of {@code byte} values, possibly empty]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code byte} primitives that interpret
 values as <i>unsigned</i> (that is, any negative value {@code b} is treated
 as the positive value {@code 256 + b}). The corresponding methods that treat
 the values as signed are found in {@link SignedBytes}, and the methods for
 which signedness is not an issue are in {@link Bytes}.

 @author Kevin Bourrillion
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.UnsignedBytes -->
</package>
<package name="com.google.common.util.concurrent">
  <!-- start class com.google.common.util.concurrent.AbstractCheckedFuture -->
  <class name="AbstractCheckedFuture" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.CheckedFuture&lt;V, E&gt;"/>
    <constructor name="AbstractCheckedFuture" type="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an {@code AbstractCheckedFuture} that wraps a delegate.]]>
      </doc>
    </constructor>
    <method name="mapException" return="E extends java.lang.Exception"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="e" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Translate from an {@link InterruptedException},
 {@link CancellationException} or {@link ExecutionException} to an exception
 of type {@code E}.  Subclasses must implement the mapping themselves.
 
 The {@code e} parameter can be an instance of {@link InterruptedException},
 {@link CancellationException}, or {@link ExecutionException}.]]>
      </doc>
    </method>
    <method name="checkedGet" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="checkedGet" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="cancel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mayInterruptIfRunning" type="boolean"/>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isDone" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="java.lang.Runnable"/>
      <param name="exec" type="java.util.concurrent.Executor"/>
    </method>
    <field name="delegate" type="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The delegate, used to pass along all our methods.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A delegating wrapper around a {@link ListenableFuture} that adds support for
 the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.
 
 @author Sven Mawson
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractCheckedFuture -->
  <!-- start class com.google.common.util.concurrent.AbstractExecutionThreadService -->
  <class name="AbstractExecutionThreadService" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.Service"/>
    <constructor name="AbstractExecutionThreadService"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="startUp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Start the service. This method is invoked on the execution thread.]]>
      </doc>
    </method>
    <method name="run"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Run the service. This method is invoked on the execution thread.
 Implementations must respond to stop requests. You could poll for lifecycle
 changes in a work loop:
 <pre>
   public void run() {
     while ({@link #isRunning()}) {
       // perform a unit of work
     }
   }
 </pre>
 ...or you could respond to stop requests by implementing {@link
 #triggerShutdown()}, which should cause {@link #run()} to return.]]>
      </doc>
    </method>
    <method name="shutDown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Stop the service. This method is invoked on the execution thread.]]>
      </doc>
    </method>
    <method name="triggerShutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Invoked to request the service to stop.]]>
      </doc>
    </method>
    <method name="executor" return="java.util.concurrent.Executor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link Executor} that will be used to run this service.
 Subclasses may override this method to use a custom {@link Executor}, which
 may configure its worker thread with a specific name, thread group or
 priority. The returned executor's {@link Executor#execute(Runnable)
 execute()} method is called when this service is started, and should return
 promptly.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="start" return="java.util.concurrent.Future&lt;com.google.common.base.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="startAndWait" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isRunning" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="state" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stop" return="java.util.concurrent.Future&lt;com.google.common.base.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stopAndWait" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Base class for services that can implement {@link #startUp}, {@link #run} and
 {@link #shutDown} methods. This class uses a single thread to execute the
 service; consider {@link AbstractService} if you would like to manage any
 threading manually.

 @author Jesse Wilson
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractExecutionThreadService -->
  <!-- start class com.google.common.util.concurrent.AbstractFuture -->
  <class name="AbstractFuture" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.Future&lt;V&gt;"/>
    <constructor name="AbstractFuture"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="isDone" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="cancel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mayInterruptIfRunning" type="boolean"/>
    </method>
    <method name="set" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Subclasses should invoke this method to set the result of the computation
 to {@code value}.  This will set the state of the future to
 {@link AbstractFuture.Sync#COMPLETED} and call {@link #done()} if the
 state was successfully changed.

 @param value the value that was the result of the task.
 @return true if the state was successfully changed.]]>
      </doc>
    </method>
    <method name="setException" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Subclasses should invoke this method to set the result of the computation
 to an error, {@code throwable}.  This will set the state of the future to
 {@link AbstractFuture.Sync#COMPLETED} and call {@link #done()} if the
 state was successfully changed.

 @param throwable the exception that the task failed with.
 @return true if the state was successfully changed.
 @throws Error if the throwable was an {@link Error}.]]>
      </doc>
    </method>
    <method name="cancel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Subclasses should invoke this method to mark the future as cancelled.
 This will set the state of the future to {@link
 AbstractFuture.Sync#CANCELLED} and call {@link #done()} if the state was
 successfully changed.

 @return true if the state was successfully changed.]]>
      </doc>
    </method>
    <method name="done"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[<p>An abstract implementation of the {@link Future} interface.  This class
 is an abstraction of {@link java.util.concurrent.FutureTask} to support use
 for tasks other than {@link Runnable}s.  It uses an
 {@link AbstractQueuedSynchronizer} to deal with concurrency issues and
 guarantee thread safety.  It could be used as a base class to
 {@code FutureTask}, or any other implementor of the {@code Future} interface.

 <p>This class implements all methods in {@code Future}.  Subclasses should
 provide a way to set the result of the computation through the protected
 methods {@link #set(Object)}, {@link #setException(Throwable)}, or
 {@link #cancel()}.  If subclasses want to implement cancellation they can
 override the {@link #cancel(boolean)} method with a real implementation, the
 default implementation doesn't support cancellation.

 <p>The state changing methods all return a boolean indicating success or
 failure in changing the future's state.  Valid states are running,
 completed, failed, or cancelled.  Because this class does not implement
 cancellation it is left to the subclass to distinguish between created
 and running tasks.

 @param <V> The result type returned by the {@code get} method
 @author Sven Mawson
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractFuture -->
  <!-- start class com.google.common.util.concurrent.AbstractIdleService -->
  <class name="AbstractIdleService" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.Service"/>
    <constructor name="AbstractIdleService"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="startUp"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Start the service.]]>
      </doc>
    </method>
    <method name="shutDown"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Stop the service.]]>
      </doc>
    </method>
    <method name="executor" return="java.util.concurrent.Executor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="state" type="com.google.common.base.Service.State"/>
      <doc>
      <![CDATA[Returns the {@link Executor} that will be used to run this service.
 Subclasses may override this method to use a custom {@link Executor}, which
 may configure its worker thread with a specific name, thread group or
 priority. The returned executor's {@link Executor#execute(Runnable)
 execute()} method is called when this service is started and stopped,
 and should return promptly.

 @param state {@link State#STARTING} or {@link State#STOPPING}, used by the
     default implementation for naming the thread]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="start" return="java.util.concurrent.Future&lt;com.google.common.base.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="startAndWait" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isRunning" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="state" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stop" return="java.util.concurrent.Future&lt;com.google.common.base.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stopAndWait" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Base class for services that do not need a thread while "running"
 but may need one during startup and shutdown. Subclasses can
 implement {@link #startUp} and {@link #shutDown} methods, each
 which run in a executor which by default uses a separate thread
 for each method.

 @author Chris Nokleberg
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractIdleService -->
  <!-- start class com.google.common.util.concurrent.AbstractListenableFuture -->
  <class name="AbstractListenableFuture" extends="com.google.common.util.concurrent.AbstractFuture&lt;V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"/>
    <constructor name="AbstractListenableFuture"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="java.lang.Runnable"/>
      <param name="exec" type="java.util.concurrent.Executor"/>
    </method>
    <method name="done"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[<p>An abstract base implementation of the listener support provided by
 {@link ListenableFuture}. This class uses an {@link ExecutionList} to
 guarantee that all registered listeners will be executed. Listener/Executor
 pairs are stored in the execution list and executed in the order in which
 they were added, but because of thread scheduling issues there is no
 guarantee that the JVM will execute them in order. In addition, listeners
 added after the task is complete will be executed immediately, even if some
 previously added listeners have not yet been executed.
 
 <p>This class uses the {@link AbstractFuture} class to implement the
 {@code ListenableFuture} interface and simply delegates the
 {@link #addListener(Runnable, Executor)} and {@link #done()} methods to it.
 
 @param <V> The result type returned by the {@code get} method
 @author Sven Mawson
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractListenableFuture -->
  <!-- start class com.google.common.util.concurrent.AbstractService -->
  <class name="AbstractService" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.Service"/>
    <constructor name="AbstractService"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="doStart"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This method is called by {@link #start} to initiate service startup. The
 invocation of this method should cause a call to {@link #notifyStarted()},
 either during this method's run, or after it has returned. If startup
 fails, the invocation should cause a call to {@link
 #notifyFailed(Throwable)} instead.

 <p>This method should return promptly; prefer to do work on a different
 thread where it is convenient. It is invoked exactly once on service
 startup, even when {@link #start} is called multiple times.]]>
      </doc>
    </method>
    <method name="doStop"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This method should be used to initiate service shutdown. The invocation
 of this method should cause a call to {@link #notifyStopped()}, either
 during this method's run, or after it has returned. If shutdown fails, the
 invocation should cause a call to {@link #notifyFailed(Throwable)} instead.

 <p>This method should return promptly; prefer to do work on a different
 thread where it is convenient. It is invoked exactly once on service
 shutdown, even when {@link #stop} is called multiple times.]]>
      </doc>
    </method>
    <method name="start" return="java.util.concurrent.Future&lt;com.google.common.base.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stop" return="java.util.concurrent.Future&lt;com.google.common.base.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="startAndWait" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stopAndWait" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="notifyStarted"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Implementing classes should invoke this method once their service has
 started. It will cause the service to transition from {@link
 State#STARTING} to {@link State#RUNNING}.

 @throws IllegalStateException if the service is not
     {@link State#STARTING}.]]>
      </doc>
    </method>
    <method name="notifyStopped"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Implementing classes should invoke this method once their service has
 stopped. It will cause the service to transition from {@link
 State#STOPPING} to {@link State#TERMINATED}.

 @throws IllegalStateException if the service is neither {@link
     State#STOPPING} nor {@link State#RUNNING}.]]>
      </doc>
    </method>
    <method name="notifyFailed"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="cause" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Invoke this method to transition the service to the
 {@link State#FAILED}. The service will <b>not be stopped</b> if it
 is running. Invoke this method when a service has failed critically or
 otherwise cannot be started nor stopped.]]>
      </doc>
    </method>
    <method name="isRunning" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="state" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Base class for implementing services that can handle {@link #doStart} and
 {@link #doStop} requests, responding to them with {@link #notifyStarted()}
 and {@link #notifyStopped()} callbacks. Its subclasses must manage threads
 manually; consider {@link AbstractExecutionThreadService} if you need only a
 single execution thread.

 @author Jesse Wilson
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractService -->
  <!-- start class com.google.common.util.concurrent.Callables -->
  <class name="Callables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="returning" return="java.util.concurrent.Callable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="T"/>
      <doc>
      <![CDATA[Creates a {@code Callable} which immediately returns a preset value each
 time it is called.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to the {@link Callable} interface.

 @author Isaac Shum
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.Callables -->
  <!-- start interface com.google.common.util.concurrent.CheckedFuture -->
  <interface name="CheckedFuture"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"/>
    <method name="checkedGet" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Exception checking version of {@link Future#get()} that will translate
 {@link InterruptedException}, {@link CancellationException} and
 {@link ExecutionException} into application-specific exceptions.
 
 @return the result of executing the future.
 @throws E on interruption, cancellation or execution exceptions.]]>
      </doc>
    </method>
    <method name="checkedGet" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Exception checking version of {@link Future#get(long, TimeUnit)} that will
 translate {@link InterruptedException}, {@link CancellationException} and
 {@link ExecutionException} into application-specific exceptions.  On
 timeout this method throws a normal {@link TimeoutException}.
 
 @return the result of executing the future.
 @throws TimeoutException if retrieving the result timed out.
 @throws E on interruption, cancellation or execution exceptions.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code CheckedFuture} is an extension of {@link Future} that includes
 versions of the {@code get} methods that can throw a checked exception and
 allows listeners to be attached to the future.  This makes it easier to
 create a future that executes logic which can throw an exception.
 
 <p>Implementations of this interface must adapt the exceptions thrown by
 {@code Future#get()}: {@link CancellationException},
 {@link ExecutionException} and {@link InterruptedException} into the type
 specified by the {@code E} type parameter.
 
 <p>This interface also extends the ListenableFuture interface to allow
 listeners to be added. This allows the future to be used as a normal
 {@link Future} or as an asynchronous callback mechanism as needed. This
 allows multiple callbacks to be registered for a particular task, and the
 future will guarantee execution of all listeners when the task completes.
 
 @author Sven Mawson
 @param <V> The result type returned by the <tt>checkedGet</tt> methods
 @param <E> The Exception type thrown by the <tt>checkedGet</tt> methods
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.CheckedFuture -->
  <!-- start class com.google.common.util.concurrent.DaemonThreadFactory -->
  <class name="DaemonThreadFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.ThreadFactory"/>
    <constructor name="DaemonThreadFactory" type="java.util.concurrent.ThreadFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="newThread" return="java.lang.Thread"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="java.lang.Runnable"/>
    </method>
    <doc>
    <![CDATA[Wraps another {@link ThreadFactory}, making all new threads daemon threads.

 @author Charles Fry
 @author Harendra Verma
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.DaemonThreadFactory -->
  <!-- start class com.google.common.util.concurrent.ExecutionList -->
  <class name="ExecutionList" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Runnable"/>
    <constructor name="ExecutionList"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="runnable" type="java.lang.Runnable"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Add the runnable/executor pair to the list of pairs to execute.  Executes
 the pair immediately if we've already started execution.]]>
      </doc>
    </method>
    <method name="run"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Runs this execution list, executing all pairs in the order they were
 added.  Pairs added after this method has started executing the list will
 be executed immediately.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>A list of ({@code Runnable}, {@code Executor}) pairs that guarantees
 that every {@code Runnable} that is added using the add method will be
 executed in its associated {@code Executor} after {@link #run()} is called.
 {@code Runnable}s added after {@code run} is called are still guaranteed to
 execute.
 
 @author Nishant Thakkar
 @author Sven Mawson
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ExecutionList -->
  <!-- start class com.google.common.util.concurrent.Executors -->
  <class name="Executors" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Executors"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getExitingExecutorService" return="java.util.concurrent.ExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="executor" type="java.util.concurrent.ThreadPoolExecutor"/>
      <param name="terminationTimeout" type="long"/>
      <param name="timeUnit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Converts the given ThreadPoolExecutor into an ExecutorService that exits
 when the application is complete.  It does so by using daemon threads and
 adding a shutdown hook to wait for their completion.

 <p>This is mainly for fixed thread pools.
 See {@link java.util.concurrent.Executors#newFixedThreadPool(int)}.

 @param executor the executor to modify to make sure it exits when the
        application is finished
 @param terminationTimeout how long to wait for the executor to
        finish before terminating the JVM
 @param timeUnit unit of time for the time parameter
 @return an unmodifiable version of the input which will not hang the JVM]]>
      </doc>
    </method>
    <method name="getExitingScheduledExecutorService" return="java.util.concurrent.ScheduledExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="executor" type="java.util.concurrent.ScheduledThreadPoolExecutor"/>
      <param name="terminationTimeout" type="long"/>
      <param name="timeUnit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Converts the given ScheduledThreadPoolExecutor into a
 ScheduledExecutorService that exits when the application is complete.  It
 does so by using daemon threads and adding a shutdown hook to wait for
 their completion.

 <p>This is mainly for fixed thread pools.
 See {@link java.util.concurrent.Executors#newScheduledThreadPool(int)}.

 @param executor the executor to modify to make sure it exits when the
        application is finished
 @param terminationTimeout how long to wait for the executor to
        finish before terminating the JVM
 @param timeUnit unit of time for the time parameter
 @return an unmodifiable version of the input which will not hang the JVM]]>
      </doc>
    </method>
    <method name="addDelayedShutdownHook"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="java.util.concurrent.ExecutorService"/>
      <param name="terminationTimeout" type="long"/>
      <param name="timeUnit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Add a shutdown hook to wait for thread completion in the given
 {@link ExecutorService service}.  This is useful if the given service uses
 daemon threads, and we want to keep the JVM from exiting immediately on
 shutdown, instead giving these daemon threads a chance to terminate
 normally.
 @param service ExecutorService which uses daemon threads
 @param terminationTimeout how long to wait for the executor to finish
        before terminating the JVM
 @param timeUnit unit of time for the time parameter]]>
      </doc>
    </method>
    <method name="getExitingExecutorService" return="java.util.concurrent.ExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="executor" type="java.util.concurrent.ThreadPoolExecutor"/>
      <doc>
      <![CDATA[Converts the given ThreadPoolExecutor into an ExecutorService that exits
 when the application is complete.  It does so by using daemon threads and
 adding a shutdown hook to wait for their completion.

 <p>This method waits 120 seconds before continuing with JVM termination,
 even if the executor has not finished its work.

 <p>This is mainly for fixed thread pools.
 See {@link java.util.concurrent.Executors#newFixedThreadPool(int)}.

 @param executor the executor to modify to make sure it exits when the
        application is finished
 @return an unmodifiable version of the input which will not hang the JVM]]>
      </doc>
    </method>
    <method name="getExitingScheduledExecutorService" return="java.util.concurrent.ScheduledExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="executor" type="java.util.concurrent.ScheduledThreadPoolExecutor"/>
      <doc>
      <![CDATA[Converts the given ThreadPoolExecutor into a ScheduledExecutorService that
 exits when the application is complete.  It does so by using daemon threads
 and adding a shutdown hook to wait for their completion.

 <p>This method waits 120 seconds before continuing with JVM termination,
 even if the executor has not finished its work.

 <p>This is mainly for fixed thread pools.
 See {@link java.util.concurrent.Executors#newScheduledThreadPool(int)}.

 @param executor the executor to modify to make sure it exits when the
        application is finished
 @return an unmodifiable version of the input which will not hang the JVM]]>
      </doc>
    </method>
    <method name="daemonThreadFactory" return="java.util.concurrent.ThreadFactory"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@link ThreadFactory} which creates daemon threads. This is
 implemented by wrapping {@link
 java.util.concurrent.Executors#defaultThreadFactory()}, marking all new
 threads as daemon threads

 @return a {@link ThreadFactory} which creates daemon threads]]>
      </doc>
    </method>
    <method name="daemonThreadFactory" return="java.util.concurrent.ThreadFactory"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="factory" type="java.util.concurrent.ThreadFactory"/>
      <doc>
      <![CDATA[Wraps another {@link ThreadFactory}, making all new threads daemon threads.

 @param factory the {@link ThreadFactory} used to generate new threads
 @return a new {@link ThreadFactory} backed by {@code factory} whose created
         threads are all daemon threads]]>
      </doc>
    </method>
    <method name="sameThreadExecutor" return="java.util.concurrent.ExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an executor service that runs each task in the thread 
 that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This
 applies both to individually submitted tasks and to collections of tasks
 submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,
 tasks will run serially on the calling thread.  Tasks are run to
 completion before a {@code Future} is returned to the caller (unless the
 executor has been shutdown).
 
 <p>Although all tasks are immediately executed in the thread that 
 submitted the task, this {@code ExecutorService} imposes a small
 locking overhead on each task submission in order to implement shutdown 
 and termination behavior.
 
 <p>The implementation deviates from the {@code ExecutorService} 
 specification with regards to the {@code shutdownNow} method.  First, 
 "best-effort" with regards to canceling running tasks is implemented 
 as "no-effort".  No interrupts or other attempts are made to stop 
 threads executing tasks.  Second, the returned list will always be empty, 
 as any submitted task is considered to have started execution.   
 This applies also to tasks given to {@code invokeAll} or {@code invokeAny}
 which are pending serial execution, even the subset of the tasks that 
 have not yet started execution.  It is unclear from the 
 {@code ExecutorService} specification if these should be included, and 
 it's much easier to implement the interpretation that they not be.
 Finally, a call to {@code shutdown} or {@code shutdownNow} may result 
 in concurrent calls to {@code invokeAll/invokeAny} throwing 
 RejectedExecutionException, although a subset of the tasks may already 
 have been executed.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Factory and utility methods for {@link java.util.concurrent.Executor}, {@link
 ExecutorService}, and {@link ThreadFactory}.

 @author Eric Fellheimer
 @author Kyle Littlefield
 @author Justin Mahoney
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.Executors -->
  <!-- start class com.google.common.util.concurrent.FakeTimeLimiter -->
  <class name="FakeTimeLimiter" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.TimeLimiter"/>
    <constructor name="FakeTimeLimiter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="newProxy" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="T"/>
      <param name="interfaceType" type="java.lang.Class&lt;T&gt;"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="callWithTimeout" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable&lt;T&gt;"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
      <param name="amInterruptible" type="boolean"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[A TimeLimiter implementation which actually does not attempt to limit time
 at all.  This may be desirable to use in some unit tests.  More importantly,
 attempting to debug a call which is time-limited would be extremely annoying,
 so this gives you a time-limiter you can easily swap in for your real
 time-limiter while you're debugging.

 @author Kevin Bourrillion
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.FakeTimeLimiter -->
  <!-- start class com.google.common.util.concurrent.ForwardingFuture -->
  <class name="ForwardingFuture" extends="ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.Future&lt;V&gt;"/>
    <constructor name="ForwardingFuture"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="delegate" return="java.util.concurrent.Future&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="cancel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mayInterruptIfRunning" type="boolean"/>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isDone" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <doc>
    <![CDATA[A {@link Future} which forwards all its method calls to another future.
 Subclasses should override one or more methods to modify the behavior of
 the backing collection as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.
 
 @see ForwardingObject
 @author Sven Mawson
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ForwardingFuture -->
  <!-- start class com.google.common.util.concurrent.ForwardingService -->
  <class name="ForwardingService" extends="ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.Service"/>
    <constructor name="ForwardingService"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="delegate" return="com.google.common.base.Service"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="start" return="java.util.concurrent.Future&lt;com.google.common.base.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="state" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stop" return="java.util.concurrent.Future&lt;com.google.common.base.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="startAndWait" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stopAndWait" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isRunning" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A {@link Service} that forwards all method calls to another service.

 @author Chris Nokleberg
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ForwardingService -->
  <!-- start class com.google.common.util.concurrent.Futures -->
  <class name="Futures" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="makeUninterruptible" return="com.google.common.util.concurrent.UninterruptibleFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="java.util.concurrent.Future&lt;V&gt;"/>
      <doc>
      <![CDATA[Returns an uninterruptible view of a {@code Future}. If a thread is
 interrupted during an attempt to {@code get()} from the returned future, it
 continues to wait on the result until it is available or the timeout
 elapses, and only then re-interrupts the thread.]]>
      </doc>
    </method>
    <method name="makeListenable" return="com.google.common.util.concurrent.ListenableFuture&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="java.util.concurrent.Future&lt;T&gt;"/>
      <doc>
      <![CDATA[Creates a {@link ListenableFuture} out of a normal {@link Future}. The
 returned future will create a thread to wait for the source future to
 complete before executing the listeners.

 <p>Callers who have a future that subclasses
 {@link java.util.concurrent.FutureTask} may want to instead subclass
 {@link ListenableFutureTask}, which adds the {@link ListenableFuture}
 functionality to the standard {@code FutureTask} implementation.]]>
      </doc>
    </method>
    <method name="makeChecked" return="com.google.common.util.concurrent.CheckedFuture&lt;T, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="java.util.concurrent.Future&lt;T&gt;"/>
      <param name="mapper" type="&lt;any&gt;"/>
      <doc>
      <![CDATA[Creates a {@link CheckedFuture} out of a normal {@link Future} and a
 {@link Function} that maps from {@link Exception} instances into the
 appropriate checked type.

 <p>The given mapping function will be applied to an
 {@link InterruptedException}, a {@link CancellationException}, or an
 {@link ExecutionException} with the actual cause of the exception.
 See {@link Future#get()} for details on the exceptions thrown.]]>
      </doc>
    </method>
    <method name="immediateFuture" return="com.google.common.util.concurrent.ListenableFuture&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="T"/>
      <doc>
      <![CDATA[Creates a {@code ListenableFuture} which has its value set immediately upon
 construction. The getters just return the value. This {@code Future} can't
 be canceled or timed out and its {@code isDone()} method always returns
 {@code true}. It's useful for returning something that implements the
 {@code ListenableFuture} interface but already has the result.]]>
      </doc>
    </method>
    <method name="immediateCheckedFuture" return="com.google.common.util.concurrent.CheckedFuture&lt;T, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="T"/>
      <doc>
      <![CDATA[Creates a {@code CheckedFuture} which has its value set immediately upon
 construction. The getters just return the value. This {@code Future} can't
 be canceled or timed out and its {@code isDone()} method always returns
 {@code true}. It's useful for returning something that implements the
 {@code CheckedFuture} interface but already has the result.]]>
      </doc>
    </method>
    <method name="immediateFailedFuture" return="com.google.common.util.concurrent.ListenableFuture&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Creates a {@code ListenableFuture} which has an exception set immediately
 upon construction. The getters just return the value. This {@code Future}
 can't be canceled or timed out and its {@code isDone()} method always
 returns {@code true}. It's useful for returning something that implements
 the {@code ListenableFuture} interface but already has a failed
 result. Calling {@code get()} will throw the provided {@code Throwable}
 (wrapped in an {@code ExecutionException}).

 @throws Error if the throwable was an {@link Error}.]]>
      </doc>
    </method>
    <method name="immediateFailedCheckedFuture" return="com.google.common.util.concurrent.CheckedFuture&lt;T, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exception" type="E extends java.lang.Exception"/>
      <doc>
      <![CDATA[Creates a {@code CheckedFuture} which has an exception set immediately
 upon construction. The getters just return the value. This {@code Future}
 can't be canceled or timed out and its {@code isDone()} method always
 returns {@code true}. It's useful for returning something that implements
 the {@code CheckedFuture} interface but already has a failed result.
 Calling {@code get()} will throw the provided {@code Throwable} (wrapped in
 an {@code ExecutionException}) and calling {@code checkedGet()} will throw
 the provided exception itself.

 @throws Error if the throwable was an {@link Error}.]]>
      </doc>
    </method>
    <method name="chain" return="com.google.common.util.concurrent.ListenableFuture&lt;O&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="com.google.common.util.concurrent.ListenableFuture&lt;I&gt;"/>
      <param name="function" type="&lt;any&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code ListenableFuture} that wraps another
 {@code ListenableFuture}.  The result of the new future is the result of
 the provided function called on the result of the provided future.
 The resulting future doesn't interrupt when aborted.

 TODO: Add a version that accepts a normal {@code Future}

 The typical use for this method would be when a RPC call is dependent on
 the results of another RPC.  One would call the first RPC (input), create a
 function that calls another RPC based on input's result, and then call
 chain on input and that function to get a {@code ListenableFuture} of
 the result.

 @param input The future to chain
 @param function A function to chain the results of the provided future
     to the results of the returned future.  This will be run in the thread
     that notifies input it is complete.
 @return A future that holds result of the chain.]]>
      </doc>
    </method>
    <method name="chain" return="com.google.common.util.concurrent.ListenableFuture&lt;O&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="com.google.common.util.concurrent.ListenableFuture&lt;I&gt;"/>
      <param name="function" type="&lt;any&gt;"/>
      <param name="exec" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Creates a new {@code ListenableFuture} that wraps another
 {@code ListenableFuture}.  The result of the new future is the result of
 the provided function called on the result of the provided future.
 The resulting future doesn't interrupt when aborted.

 This version allows an arbitrary executor to be passed in for running the
 chained Function. When using {@link Executors#sameThreadExecutor}, the
 thread chained Function executes in will be whichever thread set the result
 of the input Future, which may be the network thread in the case of
 RPC-based Futures.

 @param input The future to chain
 @param function A function to chain the results of the provided future
     to the results of the returned future.
 @param exec Executor to run the function in.
 @return A future that holds result of the chain.]]>
      </doc>
    </method>
    <method name="compose" return="com.google.common.util.concurrent.ListenableFuture&lt;O&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="com.google.common.util.concurrent.ListenableFuture&lt;I&gt;"/>
      <param name="function" type="&lt;any&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code ListenableFuture} that wraps another
 {@code ListenableFuture}.  The result of the new future is the result of
 the provided function called on the result of the provided future.
 The resulting future doesn't interrupt when aborted.

 An example use of this method is to convert a serializable object returned
 from an RPC into a POJO.

 @param future The future to compose
 @param function A Function to compose the results of the provided future
     to the results of the returned future.  This will be run in the thread
     that notifies input it is complete.
 @return A future that holds result of the composition.]]>
      </doc>
    </method>
    <method name="compose" return="java.util.concurrent.Future&lt;O&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="java.util.concurrent.Future&lt;I&gt;"/>
      <param name="function" type="&lt;any&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code Future} that wraps another {@code Future}.
 The result of the new future is the result of the provided function called
 on the result of the provided future.

 <p>An example use of this method is to convert a Future that produces a
 handle to an object to a future that produces the object itself.

 <p>Each call to {@code Future<O>.get(*)} results in a call to
 {@code Future<I>.get(*)}, but {@code function} is only applied once, so it
 is assumed that {@code Future<I>.get(*)} is idempotent.

 <p>When calling {@link Future#get(long, TimeUnit)} on the returned
 future, the timeout only applies to the future passed in to this method.
 Any additional time taken by applying {@code function} is not considered.

 @param future The future to compose
 @param function A Function to compose the results of the provided future
     to the results of the returned future.  This will be run in the thread
     that calls one of the varieties of {@code get()}.
 @return A future that computes result of the composition.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to the {@link Future} interface.

 @author Kevin Bourrillion
 @author Nishant Thakkar
 @author Sven Mawson
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.Futures -->
  <!-- start interface com.google.common.util.concurrent.ListenableFuture -->
  <interface name="ListenableFuture"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.Future&lt;V&gt;"/>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="java.lang.Runnable"/>
      <param name="exec" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[<p>Adds a listener and executor to the ListenableFuture.
 The listener will be {@linkplain Executor#execute(Runnable) passed
 to the executor} for execution when the {@code Future}'s computation is
 {@linkplain Future#isDone() complete}.

 <p>There is no guaranteed ordering of execution of listeners, they may get
 called in the order they were added and they may get called out of order,
 but any listener added through this method is guaranteed to be called once
 the computation is complete.

 @param listener the listener to run when the computation is complete.
 @param exec the executor to run the listener in.
 @throws NullPointerException if the executor or listener was null.
 @throws RejectedExecutionException if we tried to execute the listener
 immediately but the executor rejected it.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>This interface defines a future that has listeners attached to it, which
 is useful for asynchronous workflows.  Each listener has an associated
 executor, and is invoked using this executor once the {@code Future}'s
 computation is {@linkplain Future#isDone() complete}.  The listener will be
 executed even if it is added after the computation is complete.

 <p>Usage:
 <pre>   {@code
   final ListenableFuture<?> future = myService.async(myRequest);
   future.addListener(new Runnable() {
     public void run() {
       System.out.println("Operation Complete.");
       try {
         System.out.println("Result: " + future.get());
       } catch (Exception e) {
         System.out.println("Error: " + e.message());
       }
     }
   }, exec);}</pre>

 @param <V> The type returned by {@link Future#get()}.

 @author Sven Mawson
 @author Nishant Thakkar
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.ListenableFuture -->
  <!-- start class com.google.common.util.concurrent.ListenableFutureTask -->
  <class name="ListenableFutureTask" extends="java.util.concurrent.FutureTask&lt;V&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"/>
    <constructor name="ListenableFutureTask" type="java.util.concurrent.Callable&lt;V&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a {@code ListenableFutureTask} that will upon running, execute the
 given {@code Callable}.

 @param  callable the callable task
 @throws NullPointerException if callable is null]]>
      </doc>
    </constructor>
    <constructor name="ListenableFutureTask" type="java.lang.Runnable, V"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a {@code ListenableFutureTask} that will upon running, execute the
 given {@code Runnable}, and arrange that {@code get} will return the
 given result on successful completion.

 @param  runnable the runnable task
 @param result the result to return on successful completion. If
 you don't need a particular result, consider using
 constructions of the form:
 {@code ListenableFuture<?> f =
     new ListenableFutureTask<Object>(runnable, null)}
 @throws NullPointerException if runnable is null]]>
      </doc>
    </constructor>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="java.lang.Runnable"/>
      <param name="exec" type="java.util.concurrent.Executor"/>
    </method>
    <method name="done"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A {@link FutureTask} that also implements the {@link ListenableFuture}
 interface.  Subclasses must make sure to call {@code super.done()} if they
 also override the {@link #done()} method, otherwise the listeners will not
 be called.
 
 @author Sven Mawson
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ListenableFutureTask -->
  <!-- start class com.google.common.util.concurrent.NamingThreadFactory -->
  <class name="NamingThreadFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.ThreadFactory"/>
    <constructor name="NamingThreadFactory" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new factory that delegates to the default thread factory for
 thread creation, then uses {@code format} to construct a name for the new
 thread.

 @param format a {@link String#format(String, Object...)}-compatible format
     String, to which a unique integer (0, 1, etc.) will be supplied as the
     single parameter. This integer will be unique to this instance of
     NamingThreadFactory and will be assigned sequentially.]]>
      </doc>
    </constructor>
    <constructor name="NamingThreadFactory" type="java.lang.String, java.util.concurrent.ThreadFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new factory that delegates to {@code backingFactory} for thread
 creation, then uses {@code format} to construct a name for the new thread.

 @param format a {@link String#format(String, Object...)}-compatible format
     String, to which a unique integer (0, 1, etc.) will be supplied as the
     single parameter
 @param backingFactory the factory that will actually create the threads
 @throws java.util.IllegalFormatException if {@code format} is invalid]]>
      </doc>
    </constructor>
    <method name="newThread" return="java.lang.Thread"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="java.lang.Runnable"/>
    </method>
    <field name="DEFAULT_FACTORY" type="java.util.concurrent.ThreadFactory"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A ThreadFactory which decorates another ThreadFactory to set a name on
 each thread created.

 @author Kevin Bourrillion
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.NamingThreadFactory -->
  <!-- start class com.google.common.util.concurrent.SimpleTimeLimiter -->
  <class name="SimpleTimeLimiter" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.TimeLimiter"/>
    <constructor name="SimpleTimeLimiter" type="java.util.concurrent.ExecutorService"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a TimeLimiter instance using the given executor service to
 execute proxied method calls.
 <p>
 <b>Warning:</b> using a bounded executor
 may be counterproductive!  If the thread pool fills up, any time callers
 spend waiting for a thread may count toward their time limit, and in
 this case the call may even time out before the target method is ever
 invoked.

 @param executor the ExecutorService that will execute the method calls on
     the target objects; for example, a {@link
     java.util.concurrent.Executors#newCachedThreadPool()}.]]>
      </doc>
    </constructor>
    <constructor name="SimpleTimeLimiter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a TimeLimiter instance using a {@link
 java.util.concurrent.Executors#newCachedThreadPool()} to execute proxied
 method calls.

 <p><b>Warning:</b> using a bounded executor may be counterproductive! If
 the thread pool fills up, any time callers spend waiting for a thread may
 count toward their time limit, and in this case the call may even time out
 before the target method is ever invoked.]]>
      </doc>
    </constructor>
    <method name="newProxy" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="T"/>
      <param name="interfaceType" type="java.lang.Class&lt;T&gt;"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="callWithTimeout" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable&lt;T&gt;"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
      <param name="amInterruptible" type="boolean"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[A TimeLimiter that runs method calls in the background using an
 {@link ExecutorService}.  If the time limit expires for a given method call,
 the thread running the call will be interrupted.

 @author Kevin Bourrillion
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.SimpleTimeLimiter -->
  <!-- start interface com.google.common.util.concurrent.TimeLimiter -->
  <interface name="TimeLimiter"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newProxy" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="T"/>
      <param name="interfaceType" type="java.lang.Class&lt;T&gt;"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Returns an instance of {@code interfaceType} that delegates all method
 calls to the {@code target} object, enforcing the specified time limit on
 each call.  This time-limited delegation is also performed for calls to
 {@link Object#equals}, {@link Object#hashCode}, and
 {@link Object#toString}.
 <p>
 If the target method call finishes before the limit is reached, the return
 value or exception is propagated to the caller exactly as-is. If, on the
 other hand, the time limit is reached, the proxy will attempt to abort the
 call to the target, and will throw an {@link UncheckedTimeoutException} to
 the caller.
 <p>
 It is important to note that the primary purpose of the proxy object is to
 return control to the caller when the timeout elapses; aborting the target
 method call is of secondary concern.  The particular nature and strength
 of the guarantees made by the proxy is implementation-dependent.  However,
 it is important that each of the methods on the target object behaves
 appropriately when its thread is interrupted.

 @param target the object to proxy
 @param interfaceType the interface you wish the returned proxy to
     implement
 @param timeoutDuration with timeoutUnit, the maximum length of time that
     callers are willing to wait on each method call to the proxy
 @param timeoutUnit with timeoutDuration, the maximum length of time that
     callers are willing to wait on each method call to the proxy
 @return a time-limiting proxy
 @throws IllegalArgumentException if {@code interfaceType} is a regular
     class, enum, or annotation type, rather than an interface]]>
      </doc>
    </method>
    <method name="callWithTimeout" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable&lt;T&gt;"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
      <param name="interruptible" type="boolean"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Invokes a specified Callable, timing out after the specified time limit.
 If the target method call finished before the limit is reached, the return
 value or exception is propagated to the caller exactly as-is.  If, on the
 other hand, the time limit is reached, we attempt to abort the call to the
 target, and throw an {@link UncheckedTimeoutException} to the caller.
 <p>
 <b>Warning:</b> The future of this method is in doubt.  It may be nuked, or
 changed significantly.

 @param callable the Callable to execute
 @param timeoutDuration with timeoutUnit, the maximum length of time to wait
 @param timeoutUnit with timeoutDuration, the maximum length of time to wait
 @param interruptible whether to respond to thread interruption by aborting
     the operation and throwing InterruptedException; if false, the
     operation is allowed to complete or time out, and the current thread's
     interrupt status is re-asserted.
 @return the result returned by the Callable
 @throws InterruptedException if {@code interruptible} is true and our
     thread is interrupted during execution
 @throws UncheckedTimeoutException if the time limit is reached
 @throws Exception]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Produces proxies that impose a time limit on method
 calls to the proxied object.  For example, to return the value of
 {@code target.someMethod()}, but substitute {@code DEFAULT_VALUE} if this
 method call takes over 50 ms, you can use this code:
 <pre>
   TimeLimiter limiter = . . .;
   TargetType proxy = limiter.newProxy(
       target, TargetType.class, 50, TimeUnit.MILLISECONDS);
   try {
     return proxy.someMethod();
   } catch (UncheckedTimeoutException e) {
     return DEFAULT_VALUE;
   }
 </pre>
 Please see {@code SimpleTimeLimiterTest} for more usage examples.

 @author Kevin Bourrillion
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.TimeLimiter -->
  <!-- start class com.google.common.util.concurrent.UncheckedTimeoutException -->
  <class name="UncheckedTimeoutException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UncheckedTimeoutException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UncheckedTimeoutException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UncheckedTimeoutException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UncheckedTimeoutException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Unchecked version of {@link java.util.concurrent.TimeoutException}.

 @author Kevin Bourrillion
 @since 9.09.15]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.UncheckedTimeoutException -->
  <!-- start interface com.google.common.util.concurrent.UninterruptibleFuture -->
  <interface name="UninterruptibleFuture"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.Future&lt;V&gt;"/>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <doc>
    <![CDATA[A {@code Future} whose {@code get} calls cannot be interrupted. If a thread
 is interrupted during such a call, the call continues to block until the
 result is available or the timeout elapses, and only then re-interrupts the
 thread. Obtain an instance of this type using {@link
 Futures#makeUninterruptible(Future)}.

 @author Kevin Bourrillion
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.UninterruptibleFuture -->
  <!-- start class com.google.common.util.concurrent.ValueFuture -->
  <class name="ValueFuture" extends="com.google.common.util.concurrent.AbstractListenableFuture&lt;V&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.util.concurrent.ValueFuture&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new {@code ValueFuture} in the default state.]]>
      </doc>
    </method>
    <method name="set" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newValue" type="V"/>
      <doc>
      <![CDATA[Sets the value of this future.  This method will return {@code true} if
 the value was successfully set, or {@code false} if the future has already
 been set or cancelled.

 @param newValue the value the future should hold.
 @return true if the value was successfully set.]]>
      </doc>
    </method>
    <method name="setException" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Sets the future to having failed with the given exception.  This exception
 will be wrapped in an ExecutionException and thrown from the get methods.
 This method will return {@code true} if the exception was successfully set,
 or {@code false} if the future has already been set or cancelled.

 @param t the exception the future should hold.
 @return true if the exception was successfully set.]]>
      </doc>
    </method>
    <method name="cancel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mayInterruptIfRunning" type="boolean"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>A ValueFuture is never considered in the running state, so the
 {@code mayInterruptIfRunning} argument is ignored.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A simple ListenableFuture that holds a value or an exception.

 @author Sven Mawson
 @since 9.09.15 <b>tentative</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ValueFuture -->
</package>

</api>
