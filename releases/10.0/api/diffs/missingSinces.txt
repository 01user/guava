OK: com.google.common.collect.ArrayTable Class
OK: com.google.common.util.concurrent.Atomics Class
OK: com.google.common.collect.BoundType Class
OK: com.google.common.collect.ContiguousSet Class
OK: com.google.common.collect.DiscreteDomain Class
OK: com.google.common.collect.DiscreteDomains Class
OK: com.google.common.base.Equivalence.Wrapper Class
OK: com.google.common.util.concurrent.ExecutionError Class
OK: com.google.common.util.concurrent.ForwardingExecutorService Class
OK: com.google.common.util.concurrent.ForwardingListeningExecutorService Class
OK: com.google.common.collect.ForwardingMap.StandardEntrySet Class
OK: com.google.common.collect.ForwardingMap.StandardKeySet Class
OK: com.google.common.collect.ForwardingMap.StandardValues Class
OK: com.google.common.collect.ForwardingMultiset.StandardElementSet Class
OK: com.google.common.util.concurrent.FutureCallback Interface
OK: com.google.common.net.HostAndPort Class
OK: com.google.common.collect.ImmutableCollection.Builder Class
OK: com.google.common.util.concurrent.JdkFutureAdapters Class
OK: com.google.common.util.concurrent.ListeningExecutorService Interface
OK: com.google.common.util.concurrent.ListeningScheduledExecutorService Interface
OK: com.google.common.util.concurrent.Monitor Class
OK: com.google.common.util.concurrent.Monitor.Guard Class
OK: com.google.common.base.Optional Class
OK: com.google.common.collect.Range Class
OK: com.google.common.collect.Ranges Class
OK: com.google.common.base.Splitter.MapSplitter Class
OK: com.google.common.base.Stopwatch Class
OK: com.google.common.util.concurrent.UncheckedExecutionException Class
OK: com.google.common.util.concurrent.Uninterruptibles Class
OK: com.google.common.primitives.UnsignedLongs Class
MISSING @SINCE TAG: com.google.common.base.Equivalence Constructor (void)
MISSING @SINCE TAG: com.google.common.base.Ticker Constructor (void)
NO DOC BLOCK: com.google.common.collect.TreeMultiset Method add(E, int)
OK: com.google.common.util.concurrent.Futures Method addCallback(com.google.common.util.concurrent.ListenableFuture<V>, com.google.common.util.concurrent.FutureCallback<? super V>)
OK: com.google.common.util.concurrent.Futures Method addCallback(com.google.common.util.concurrent.ListenableFuture<V>, com.google.common.util.concurrent.FutureCallback<? super V>, java.util.concurrent.Executor)
OK: com.google.common.util.concurrent.AbstractFuture Method addListener(java.lang.Runnable, java.util.concurrent.Executor)
OK: com.google.common.util.concurrent.Futures Method allAsList(com.google.common.util.concurrent.ListenableFuture[])
OK: com.google.common.util.concurrent.Futures Method allAsList(java.lang.Iterable<? extends com.google.common.util.concurrent.ListenableFuture<? extends V>>)
OK: com.google.common.base.Joiner.MapJoiner Method appendTo(A extends java.lang.Appendable, java.lang.Iterable<? extends java.util.Map.Entry<?, ?>>)
OK: com.google.common.base.Joiner.MapJoiner Method appendTo(java.lang.StringBuilder, java.lang.Iterable<? extends java.util.Map.Entry<?, ?>>)
OK: com.google.common.base.Predicates Method assignableFrom(java.lang.Class<?>)
NO DOC BLOCK: com.google.common.collect.ConcurrentHashMultiset Method clear()
OK: com.google.common.collect.TreeMultiset Method comparator()
NO DOC BLOCK: com.google.common.collect.ImmutableMultiset Method containsAll(java.util.Collection<?>)
OK: com.google.common.collect.Multisets Method containsOccurrences(com.google.common.collect.Multiset<?>, com.google.common.collect.Multiset<?>)
OK: com.google.common.io.ByteStreams Method copy(java.io.InputStream, com.google.common.io.OutputSupplier<? extends java.io.OutputStream>)
OK: com.google.common.util.concurrent.ListenableFutureTask Method create(java.lang.Runnable, V)
OK: com.google.common.util.concurrent.ListenableFutureTask Method create(java.util.concurrent.Callable<V>)
OK: com.google.common.collect.Maps Method difference(java.util.Map<? extends K, ? extends V>, java.util.Map<? extends K, ? extends V>, com.google.common.base.Equivalence<? super V>)
OK: com.google.common.base.Equivalence Method doEquivalent(T, T)
OK: com.google.common.base.Equivalence Method doHash(T)
OK: com.google.common.base.Equivalence Method equivalentTo(T)
OK: com.google.common.util.concurrent.ExecutionList Method execute()
OK: com.google.common.base.Functions Method forSupplier(com.google.common.base.Supplier<T>)
OK: com.google.common.net.InternetDomainName Method from(java.lang.String)
OK: com.google.common.util.concurrent.Futures Method get(java.util.concurrent.Future<V>, java.lang.Class<X>)
OK: com.google.common.util.concurrent.Futures Method get(java.util.concurrent.Future<V>, long, java.util.concurrent.TimeUnit, java.lang.Class<X>)
OK: com.google.common.util.concurrent.AbstractExecutionThreadService Method getServiceName()
OK: com.google.common.util.concurrent.Futures Method getUnchecked(java.util.concurrent.Future<V>)
OK: com.google.common.net.InetAddresses Method increment(java.net.InetAddress)
OK: com.google.common.collect.Multimaps Method index(I extends java.lang.Object & java.lang.Iterable<V> & java.util.Iterator<V>, com.google.common.base.Function<? super V, K>)
OK: com.google.common.collect.Multimaps Method index(java.util.Iterator<V>, com.google.common.base.Function<? super V, K>)
OK: com.google.common.util.concurrent.AbstractFuture Method interruptTask()
NO DOC BLOCK: com.google.common.collect.ConcurrentHashMultiset Method isEmpty()
OK: com.google.common.primitives.Doubles Method isFinite(double)
OK: com.google.common.primitives.Floats Method isFinite(float)
OK: com.google.common.net.InetAddresses Method isMappedIPv4Address(java.lang.String)
OK: com.google.common.net.InetAddresses Method isMaximum(java.net.InetAddress)
OK: com.google.common.net.InternetDomainName Method isValid(java.lang.String)
NO DOC BLOCK: com.google.common.collect.ImmutableSortedSet Method iterator()
MISSING @SINCE TAG: com.google.common.collect.TreeMultiset Method iterator()
OK: com.google.common.base.Joiner.MapJoiner Method join(java.lang.Iterable<? extends java.util.Map.Entry<?, ?>>)
OK: com.google.common.util.concurrent.Futures Method lazyTransform(java.util.concurrent.Future<I>, com.google.common.base.Function<? super I, ? extends O>)
OK: com.google.common.util.concurrent.MoreExecutors Method listeningDecorator(java.util.concurrent.ExecutorService)
OK: com.google.common.util.concurrent.MoreExecutors Method listeningDecorator(java.util.concurrent.ScheduledExecutorService)
OK: com.google.common.collect.Tables Method newCustomTable(java.util.Map<R, java.util.Map<C, V>>, com.google.common.base.Supplier<? extends java.util.Map<C, V>>)
OK: com.google.common.base.Equivalence Method onResultOf(com.google.common.base.Function<F, ? extends T>)
OK: com.google.common.base.Equivalence Method pairwise()
OK: com.google.common.collect.Iterators Method peekingIterator(com.google.common.collect.PeekingIterator<T>)
OK: com.google.common.collect.Multisets Method removeOccurrences(com.google.common.collect.Multiset<?>, com.google.common.collect.Multiset<?>)
OK: com.google.common.collect.Multisets Method retainOccurrences(com.google.common.collect.Multiset<?>, com.google.common.collect.Multiset<?>)
OK: com.google.common.collect.TreeBasedTable Method row(R)
OK: com.google.common.util.concurrent.Futures Method successfulAsList(com.google.common.util.concurrent.ListenableFuture[])
OK: com.google.common.util.concurrent.Futures Method successfulAsList(java.lang.Iterable<? extends com.google.common.util.concurrent.ListenableFuture<? extends V>>)
OK: com.google.common.base.Ticker Method systemTicker()
OK: com.google.common.net.InetAddresses Method toAddrString(java.net.InetAddress)
OK: com.google.common.collect.Tables Method transformValues(com.google.common.collect.Table<R, C, V1>, com.google.common.base.Function<? super V1, V2>)
OK: com.google.common.collect.Maps Method uniqueIndex(java.util.Iterator<V>, com.google.common.base.Function<? super V, K>)
OK: com.google.common.collect.Maps Method uniqueIndex(I extends java.lang.Object & java.lang.Iterable<V> & java.util.Iterator<V>, com.google.common.base.Function<? super V, K>)
OK: com.google.common.collect.Iterables Method unmodifiableIterable(com.google.common.collect.ImmutableCollection<E>)
OK: com.google.common.collect.Iterators Method unmodifiableIterator(com.google.common.collect.UnmodifiableIterator<T>)
OK: com.google.common.collect.Multimaps Method unmodifiableListMultimap(com.google.common.collect.ImmutableListMultimap<K, V>)
OK: com.google.common.collect.Multimaps Method unmodifiableMultimap(com.google.common.collect.ImmutableMultimap<K, V>)
OK: com.google.common.collect.Multisets Method unmodifiableMultiset(com.google.common.collect.ImmutableMultiset<E>)
OK: com.google.common.collect.Multimaps Method unmodifiableSetMultimap(com.google.common.collect.ImmutableSetMultimap<K, V>)
OK: com.google.common.base.Splitter Method withKeyValueSeparator(com.google.common.base.Splitter)
OK: com.google.common.base.Splitter Method withKeyValueSeparator(java.lang.String)
OK: com.google.common.base.Equivalence Method wrap(S extends T)
OK: com.google.common.primitives.Doubles Field BYTES
OK: com.google.common.primitives.Floats Field BYTES
OK: com.google.common.primitives.Ints Field MAX_POWER_OF_TWO
OK: com.google.common.primitives.Longs Field MAX_POWER_OF_TWO
OK: com.google.common.primitives.Shorts Field MAX_POWER_OF_TWO
OK: com.google.common.primitives.SignedBytes Field MAX_POWER_OF_TWO
OK: com.google.common.primitives.UnsignedBytes Field MAX_POWER_OF_TWO
